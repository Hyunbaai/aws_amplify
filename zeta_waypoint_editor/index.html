<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Waypoint Map</title>

    <!-- Leaflet.js 라이브러리의 CSS 및 JS 파일 포함 -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>
    <!-- YAML 라이브러리 (js-yaml) 포함 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <!-- jQuery 라이브러리 추가 -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <!-- jquery.finger.js 라이브러리 추가 -->
    <script src="//rawgit.com/ngryman/jquery.finger/v0.1.2/dist/jquery.finger.js"></script>

    <!-- Supabase 클라이언트 라이브러리 추가 -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js"></script>

    <script>
        document.addEventListener("DOMContentLoaded", () => {
            // Supabase 설정 - URL과 익명 키를 본인의 것으로 교체하세요
            const SUPABASE_URL = 'https://wbjwefiaglmtwdtulhbo.supabase.co';
            const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndiandlZmlhZ2xtdHdkdHVsaGJvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MjE0NzAzMjksImV4cCI6MjAzNzA0NjMyOX0.vKQBE2k0qU2SsRMH8sVN0RKdByWGLQ6d_MxgB8J5EOE';
            window.supabase = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY); // window 객체에 추가하여 전역으로 사용 가능하도록 설정
        });
    </script>

    <style>
        /* Mobile App 제목 폰트 스타일 */
        #title {
            font-family: 'Arial', sans-serif; /* 원하는 글꼴 */
            font-size: 21px; /* 폰트 크기 조정 */
            font-weight: bold; /* 글씨 굵기 */
            text-align: center; /* 텍스트 중앙 맞춤 */
            margin-top: 20px; /* 필요에 따라 여백 추가 */
            color: #333333; /* 글씨 색상 */
        }
        /* 지도의 높이를 설정하여 화면에 표시 */
        #map {
            position: relative;
            width: 100%;         /* 너비를 100%로 설정해 화면을 채움 */
            height: 50vh;        /* 높이를 뷰포트 높이의 50%로 설정 */
        }

        .content {
            text-align: center;
            color: white; /* 텍스트 색상 */
        }

        /* 우측 하단 고정 링크 */
        .floating-link {
            position: fixed;
            bottom: 20px; /* 하단 여백 */
            right: 20px; /* 우측 여백 */
            background-color: #007bff; /* 파란색 배경 */
            color: white; /* 흰색 글씨 */
            text-decoration: none;
            font-size: 12px;
            padding: 8px 12px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: background 0.3s ease, transform 0.2s ease;
            z-index: 1000;
        }

        .floating-link:hover {
            background-color: #0056b3; /* Hover 시 더 진한 파란색 */
        }

        .floating-link:active {
            transform: scale(0.95); /* 클릭 시 살짝 작아지는 효과 */
        }

        /* 페이지 레이아웃 요소 */
        .box {
            border: 1px solid white;
            padding: 10px;
            margin: 10px;
            display: inline-block;
        }
        
        /* 아이콘 세팅 */
        .custom-div-icon {
            background-color: #ff5722;    /* 원형 아이콘 배경색 */
            border: none;                   /* 테두리를 없애기 */
            border-radius: 50%;             /* 원형으로 만들기 */
            width: 3vh;                     /* 아이콘의 너비 */
            height: 3vh;                    /* 아이콘의 높이 */
            display: flex;                  /* 내용을 중앙에 배치하기 위한 설정 */
            justify-content: center;        /* 가로 중앙 정렬 */
            align-items: center;            /* 세로 중앙 정렬 */
            overflow: hidden;               /* 원형 영역을 넘어서는 부분을 숨기기 */
        }
        .custom-div-icon img {
            width: 100%;                    /* 이미지의 너비를 아이콘의 너비에 맞추기 */
            height: 100%;                   /* 이미지의 높이를 아이콘의 높이에 맞추기 */
            object-fit: cover;              /* 이미지의 비율 유지 및 영역에 맞게 조정 */
        }
        /* 버튼 세팅 */
        .save-button {
            position: absolute;             /* 버튼을 절대 위치로 설정 */
            right: 1vh;                     /* 화면의 오른쪽 끝에서 10px 떨어진 위치 */
        }
        /* 폰트 세팅 */
        label {
            font-family: 'Times New Roman'; /* 원하는 글꼴 이름을 설정 */
            font-size: 14px;                /* 글씨 크기 설정 */
            font-weight: bold;              /* 글씨 두께 설정 */
            color: #333;                  /* 글씨 색상 설정 */
        }
        /* 로봇 아이콘 세팅 */
        .robot-icon {
            font-size: 2vh;
            text-align: center;
            line-height: 3vh;              /* 아이콘의 세로 정렬 */
        }
        /* 팝업 스타일 수정 */
        .popup-container {
            position: fixed;
            right: 1vh;
            top: 8.5vh;
            display: flex;
            flex-direction: column;  /* 세로 방향으로 쌓기 */
            flex-wrap: wrap;         /* 아이템이 넘치면 새로운 열로 감 */
            gap: 1vh;                /* 각 팝업 사이 간격 */
            max-height: 50vh;        /* 화면 높이의 50%까지만 사용 */
            z-index: 1000;           /* 맵 위에 표시되도록 z-index 조정 */
            overflow-y: scroll;        /* 넘칠 경우 스크롤 생성 */
        }
        .popup {
            width: 18vh;
            max-width: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid black;
            padding: 1vh;
            border-radius: 0.5vh;
            box-shadow: 0vh 0vh 1vh rgba(0, 0, 0, 0.1);
            font-size: 1.2vh; /* 폰트 크기 줄이기 */
            margin-bottom: 2vh; /* 각 팝업창 간격 */
        }
        .popup h4 {
            margin: 0;
            font-size: 1.6vh; /* 제목 폰트 크기 */
        }
        .popup .info {
            margin-top: 0.3vh; /* 상단 간격 줄이기 */
        }

        .popup .info p {
            margin: 0.5vh 0; /* 각 항목 간의 간격 줄이기 */
            line-height: 2vh; /* 줄 간격 줄이기 */
        }
        /* 제목과 버튼이 한 줄에 들어가도록 컨테이너 스타일 */
        .header-container {
            display: flex;
            align-items: center;         /* 수직 중앙 정렬 */
            justify-content: space-between; /* 양쪽 끝 정렬 */
            width: 100%;                 /* 전체 너비 사용 */
            padding: 0.5vh;              /* 패딩 조정 */
            font-size: 2vh;              /* 텍스트 크기 조정 */
        }
        /* Deadlock Probability 텍스트 스타일 */
        .header-title {
            margin: 0;
            font-size: 1.8vh;
        }
        /* 버튼 컨테이너 */
        .zoom-buttons {
            display: flex;
            gap: 0.25vh;                  /* 버튼 간격 */
        }
        .zoom-buttons button {
            font-size: 1.2vh;
            padding: 0.25vh 0.5vh;          /* 버튼 크기 조정 */
        }
        /* 행렬을 감싸는 Wrapper 스타일 */
        #matrixContainerWrapper {
            width: 100%;
            height: calc(100vh - 8vh); /* 헤더와 줌 버튼을 제외한 높이 설정 */
            overflow: auto;            /* 행렬이 Wrapper를 벗어나면 스크롤 표시 */
        }
        /* 확률 행렬 스타일 */
        #probabilityMatrix {
            position: absolute;
            bottom: 1vh;
            left: 1vh;
            z-index: 2000;
            display: grid;
            gap: 0.5vh;
            margin-top: 2vh;
            background-color: rgba(255, 255, 255, 0.7); /* 반투명 흰색 배경 */
            padding: 1vh;                                 
            border-radius: 0.5vh;
            transform-origin: top left; /* 확대/축소 원점 설정 */
        }
        /* 행렬 셀 스타일 */
        .matrix-cell {
            width: 2.5vh;
            height: 2.5vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9vh;
            color: black;
            border: 1px solid #000;
        }
        /* 라벨 셀 스타일 */
        .label-init-cell {
            background-color: rgba(0, 0, 0, 0.7);       /* 반투명 검은색 배경 */
        }
        .label-cell {
            background-color: rgba(200, 200, 200, 0.7); /* 반투명 회색 배경 */
        }
        /* 확률에 따른 셀 색상 변화 */
        .low-probability { background-color: green; }
        .medium-probability { background-color: yellow; color: black; }
        .high-probability { background-color: red; }
        /* Waypoint 목록 팝업 스타일 */
        #waypoint-popup {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50vh;
            max-height: 70%;
            background-color: white;
            border: 1px solid #ccc;
            padding: 2vh;
            box-shadow: 0vh 0vh 10vh rgba(0, 0, 0, 0.1);
            overflow-y: auto; /* 내용이 넘칠 경우 스크롤바 표시 */
            z-index: 1000;
        }
        #waypoint-popup h2 { margin-top: 0; }
        #waypoint-popup ul {
            list-style-type: none;
            padding: 0;
        }
        #waypoint-popup ul li {
            cursor: pointer;
            padding: 0.5vh;
            border: 1px solid #ddd;
            margin-bottom: 0.5vh;
            text-align: center;
        }
        #popup ul li:hover {
            background-color: #f0f0f0;
        }
        #overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 500;
        }
        .item-space {
            margin-right: 1.5vh; /* 오른쪽에 10px 간격 추가 */
        }
        /* Waypoint 삭제 확인 팝업 스타일 */
        .popup-overlay {
            display: flex;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.5); /* 배경 어둡게 */
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }   
        .popup-content {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            width: 80%;
            max-width: 400px;
            text-align: center;
            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.3);
        }
        .popup-content h3 {
            margin-bottom: 20px;
        }
        .button-row-delete {
            display: flex;
            justify-content: space-around;
        }
        .button-row-delete button {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #confirmDeleteButton {
            background-color: #ff4d4d;
            color: white;
        }
        #cancelDeleteButton {
            background-color: #ccc;
            color: black;
        }
        /* Waypoint Point 정보 팝업 스타일 */
        #waypoint-popup2 {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40vh;
            max-height: 70%;
            background-color: white;
            border: 1px solid #ccc;
            padding: 0vh 2vh 0vh 2vh;
            box-shadow: 0vh 0vh 1vh rgba(0, 0, 0, 0.1);
            overflow-y: auto; /* 내용이 넘칠 경우 스크롤바 표시 */
            z-index: 1000;
        }
        #waypoint-popup2 h2 { margin-top: 0; padding: 0.5vh; }
        #waypoint-popup2 ul {
            list-style-type: none;
            padding: 0;
        }
        #waypoint-popup2 ul li {
            cursor: pointer;
            padding: 0.5vh;
            border: 1px solid #ddd;
            margin-bottom: 0.5vh;
            text-align: center;
        }
        .button-row {
            margin-top: 1vh;        /* 버튼과 위 요소 사이의 간격 */
            display: flex;          /* 플렉스박스를 사용하여 한 줄로 배치 */
            justify-content: space-between; /* 버튼 간의 공간을 자동으로 나눔 */
        }
        .button-row button {
            flex: 1;                /* 버튼의 너비를 동일하게 설정 */
            margin-right: 2vh;      /* 각 버튼 사이에 간격 추가 */
            padding: 1vh;           /* 입력란 내부에 패딩을 추가하여 여유 공간 확보 */
        }
        .button-row button:last-child {
            margin-right: 0.3vh;        /* 마지막 버튼은 오른쪽 간격을 없앰 */
        }

        .text-row {
            margin-top: 1vh;       /* 버튼과 위 요소 사이의 간격 */
            margin-bottom: 1vh;
            display: flex;          /* 플렉스박스를 사용하여 한 줄로 배치 */
            gap: 2vh;              /* 입력란 사이의 간격을 20px로 설정 */
        }
        .text-row input {
            flex-basis: 45%;        /* 입력란의 너비를 동일하게 설정 */
            padding: 1vh;           /* 입력란 내부에 패딩을 추가하여 여유 공간 확보 */
            font-size: 10px;        /* 입력란 텍스트 크기 설정 */
        }
        /* Waypoint Point 수정 팝업창 스타일 */
        #editFormPopup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 35vh;
            background-color: white;
            padding: 0vh 2vh 0vh 2vh;
            box-shadow: 0vh 0vh 1vh rgba(0, 0, 0, 0.3); /* 그림자 효과 */
            z-index: 1000; /* 배경보다 높은 z-index */
            border-radius: 0.8vh;
            text-align: center;
        }
        /* 팝업창 내부 입력 필드 스타일 */
        #editFormPopup input {
            width: 100%;
            margin: 0.5vh 0;
            padding: 0.8vh;
            box-sizing: border-box;
        }
        #editFormPopup button {
            margin: 1vh 0.5vh;
            padding: 0.8vh 1.2vh;
        }
        .popup-header {
            cursor: move;
            padding: 1vh;
            background-color: #f1f1f1;
            border-bottom: 1px solid #ddd;
            text-align: center;
        }
        .draggable-popup {
            position: absolute;
            top: 30%;
            left: 7.5%;
            width: 42vh;
            background-color: white;
            padding: 0vh 2vh 1vh 2vh;
            box-shadow: 0vh 0vh 1vh rgba(0, 0, 0, 0.3);
            z-index: 1000;
            border-radius: 0.8vh;
            text-align: center;
        }
        .draggable-popup-robot {
            position: absolute;
            top: 30%;
            left: 7.5%;
            width: 42vh;
            background-color: white;
            padding: 0vh 2vh 1vh 2vh;
            box-shadow: 0vh 0vh 1vh rgba(0, 0, 0, 0.3);
            z-index: 1000;
            border-radius: 0.8vh;
            text-align: center;
        }
        /* 지도 팝업 스타일 */
        .map-popup {
            position: absolute;
            top: 30%;
            left: 7.5%;
            transform: translate(-50%, -50%);
            width: 50vh;
            height: 30vh;
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 0vh 0vh 1vh rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none; /* 초기 상태에서는 팝업을 숨김 */
        }
        /* Point 추가용 지도 팝업 스타일 */
        .map-popup-point {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50vh;
            height: 60vh;
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 0vh 0vh 1vh rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none; /* 초기 상태에서는 팝업을 숨김 */
        }
        /* Point 추가용 지도의 Waypoint Icon 스타일 */
        .custom-div-icon .circle-icon {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 3vh;
            height: 3vh;
            border-radius: 50%;  /* 동그라미 */
            background-color: #007BFF;  /* 배경색 (파란색) */
            color: white;
            font-weight: bold;
            font-size: 12px;
            text-align: center;
        }
        /* Waypoint 목록 팝업 스타일 */
        #waypoint-save-popup {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50vh;
            max-height: 70%;
            background-color: white;
            border: 1px solid #ccc;
            padding: 2vh;
            box-shadow: 0vh 0vh 1vh rgba(0, 0, 0, 0.1);
            overflow-y: auto; /* 내용이 넘칠 경우 스크롤바 표시 */
            z-index: 1000;
        }
        #waypoint-save-popup h2 { margin-top: 0; }
        #waypoint-save-popup ul {
            list-style-type: none;
            padding: 0;
        }
        #waypoint-save-popup ul li {
            cursor: pointer;
            padding: 0.5vh;
            border: 1px solid #ddd;
            margin-bottom: 0.5vh;
            text-align: center;
        }
        /* Waypoint 저장 팝업 스타일 */
        #save-waypoint-popup {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50vh;
            max-height: 70%;
            background-color: white;
            border: 1px solid #ccc;
            padding: 2vh 1vh 2vh 1vh;
            box-shadow: 0vh 0vh 1vh rgba(0, 0, 0, 0.1);
            overflow-y: auto; /* 내용이 넘칠 경우 스크롤바 표시 */
            z-index: 1000;
        }
        #save-waypoint-popup h2 { margin-top: 0; }
        #save-waypoint-popup ul {
            list-style-type: none;
            padding: 0;
        }
        #save-waypoint-popup ul li {
            cursor: pointer;
            padding: 0.5vh;
            border: 1px solid #ddd;
            margin-bottom: 0.5vh;
            text-align: center;
        }
        .circle-number {
        width: 3vh;
        height: 3vh;
        border-radius: 50%;
        background-color: lightgray;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 1vh;
        font-weight: bold;
        }
        .waypoint-label {
        flex: 1;
        font-size: 12px;
        }
        .select-button {
        width: 8vh;
        height: 3vh;
        border: 2px solid black;
        background-color: white;
        color: black;
        border-radius: 0.5vh;
        cursor: pointer;
        }
        .select-button.selected {
        background-color: gray;
        color: white;
        }
        /* 컨트롤러 팝업 스타일 */
        .controller-popup {
            position: fixed;
            bottom: 6vh;
            right: 5.75vh;
            width: 39vh;
            height: 22vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0vh 0vh 1vh rgba(0, 0, 0, 0.3);
            border-radius: 1vh;
            z-index: 1000;
            flex-direction: column; /* 세로 방향으로 정렬 */
            padding: 1vh; /* 팝업 안쪽 여백 추가 */
        }
        .controller-container {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-top: 2vh; /* 아래쪽 여백 제거 */
            padding: 0 2vh; /* 양쪽에 동일한 패딩 추가 */
        }
        /* 컨트롤러 버튼 스타일 */
        .controller-btn {
            width: 5vh;
            height: 5vh;
            font-size: 1.5em;
            background: #d9d9d9;
            border: none;
            border-radius: 0.8vh;
            margin: 0.2vh;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;               /* 버튼 내용 가운데 정렬 */
            justify-content: center;
            align-items: center;
            box-shadow: 0vh 0vh 1.5vh rgba(0, 0, 0, 0.2);
            padding: 2vh;
            flex-direction: column;
        }
        .controller-btn:active {
            background: #a6a6a6;
        }
        .controller-grid {
            display: grid;
            grid-template-areas:
                ". up ."
                "left stop right"
                ". down .";
            gap: 0.5vh;
            padding-left: 1.5vh; /* 왼쪽 여백 추가 */
        }
        .controller-btn.up { grid-area: up; }
        .controller-btn.down { grid-area: down; }
        .controller-btn.left { grid-area: left; }
        .controller-btn.right { grid-area: right; }
        .controller-btn.stop { grid-area: stop; }
        .speed-control {
            display: flex;
            justify-content: space-between;
            width: 100%;
            gap: 0.5vh;
            margin-left: 1vh; /* 왼쪽 여백 추가 */
        }
        
        .speed-control-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0; /* 상하 여백 제거 */
        }
        
        .speed-display {
            font-size: 1.8vh;
            font-weight: bold;
            margin: 0.5vh 0;
        }
        
        .adjust-buttons {
            display: flex;
            flex-direction: column;
            gap: 1vh;
        }
        /* Close 버튼 스타일 */
        .close-button {
            position: relative;
            top: -2vh;
            right: -9.9vh; /* 오른쪽으로 약간 이동 */
            font-size: 2vh; /* 버튼 크기 조정 */
            margin-bottom: 0; /* 아래쪽 여백 제거 */
            border-radius: 0.8vh; /* 둥근 모서리 설정 */
        }

        /* 팝업 스타일 */
        #robotListPopup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #ffffff;
            padding: 30px;
            border: 1px solid #ddd;
            border-radius: 15px;
            box-shadow: 0px 10px 20px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            max-width: 600px;
            max-height: 80%; /* 최대 높이 */
            overflow-y: auto; /* 스크롤 가능 */
            font-family: Arial, sans-serif;
        }

        /* 제목 스타일 */
        #popupTitle {
            font-size: 1.5rem;
            font-weight: bold;
            color: #1976d2; /* 강조된 파란색 */
            text-align: center;
            margin-bottom: 20px;
        }

        /* 로봇 리스트 스타일 */
        #robotList {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }

        #robotList li {
            padding: 15px;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 10px;
            margin-bottom: 10px;
            font-size: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #robotList li strong {
            font-weight: bold;
        }

        #robotList li:hover {
            background-color: #e1f5fe;
            transform: translateY(-2px);
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
        }

        /* 닫기 버튼 */
        #closePopupButton {
            display: block;
            margin: 20px auto 0 auto;
            padding: 10px 20px;
            background: #1976d2;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }

        #closePopupButton:hover {
            background-color: #0d47a1;
        }
    </style>
</head>
<body>
    <h3 id="title">ZETA Satellite Robotics WP Editor</h3>
    <!-- 지도가 표시될 영역 -->
    <div id="map">
        
    </div>

    <!-- 우측 하단 고정 링크 -->
    <a href="https://fleet-management-prototype.vercel.app/" target="_blank" class="floating-link">
        Open Fleet Management
    </a>
    <!-- 사용자가 로봇을 추가 및 제어할 수 있는 버튼 -->
    <div id="robot-control">
        <label>[Robot Control] </label>
        <button onclick="openRobotListPopup()">Add Robot</button>
        <!-- 선택된 로봇을 표시할 드롭다운 -->
        <select id="selectedRobotDropdown" onchange="handleRobotSelectionChange()" >
            <option value="">Selected a Robot</option>
        </select>
        <button onclick="robotController()">Robot Controller</button>
    </div>

    <!-- Robot List 팝업 (초기 상태: 숨김) -->
    <div id="robotListPopup" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border: 1px solid black; padding: 20px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);">
        <h3>Robot List</h3>
        <ul id="robotList"></ul>
        <!-- <button onclick="closeRobotListPopup()">Close</button> -->
    </div>



    <!-- 컨트롤러 팝업 -->
    <div id="controllerPopup" class="controller-popup" style="display: none;">
        <div class="controller-container">
            <!-- 방향 조작 버튼 (왼쪽) -->
            <div class="controller-grid">
                <button class="controller-btn up" onclick="sendControl('forward')">↑</button>
                <button class="controller-btn left" onclick="sendControl('left')">←</button>
                <button class="controller-btn stop" onclick="sendControl('stop')">■</button>
                <button class="controller-btn right" onclick="sendControl('right')">→</button>
                <button class="controller-btn down" onclick="sendControl('backward')">↓</button>
            </div>
        </div>
        <!-- Close 버튼 -->
        <div class="close-button">
            <button onclick="closeControllerPopup()">Close</button>
        </div>
    </div>
    <!-- 사용자가 Waypoint를 생성 및 저장할 수 있는 버튼 -->
    <div id="waypoint-edit">
        <label>[Waypoint Edit] </label>
        <button onclick="resetMap()">Reset</button>
    </div>
    

    <!-- 새로운 DB Data 섹션 -->
    <div id="db-data-section">
        <label>[DB Data]</label>
        <button onclick="openDBRobotPopup()"> DB Waypoint List </button>
        <button id="startNavigationBtn" onclick="sendAllWaypoints(selectedPathId)">Start Navigation</button>
        <button id="reverseNavigationBtn" onclick="sendAllWaypoints(selectedPathId,0,true)">Create Reverse Path</button>
        <button id="cancelBtn" onclick="sendAllWaypoints(selectedPathId,-1,false)"style="background-color: #dc3545; color: white;">Navigation Cancel</button>
        <button id="clonePathButton" onclick="openRobotSelectionPopup()">Clone Robot Path</button>
    </div>

    <!-- Path 목록을 표시하는 팝업 -->
    <div id="pathListPopup" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 90%; max-width: 400px; padding: 20px; background-color: #ffffff; border-radius: 8px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); z-index: 1000;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h3 style="margin: 0; font-size: 18px;">Path 목록</h3>
            <div style="display: flex; gap: 8px;">
                <button onclick="openAddPathPopup()" style="background: none; border: none; font-size: 14px; padding: 5px 10px; background-color: #007bff; color: white; border-radius: 5px; cursor: pointer;">+Add</button>
                <button onclick="closePathListPopup()" style="background: none; border: none; font-size: 20px; font-weight: bold; cursor: pointer;">&times;</button>
            </div>
        </div>

        <!-- Path 목록을 표시할 영역 -->
        <div id="pathListDisplay" style="display: flex; flex-direction: column; gap: 10px; max-height: 300px; overflow-y: auto; padding-right: 5px;"></div>

        <button onclick="closePathListPopup()" style="margin-top: 20px; width: 100%; padding: 10px; font-size: 16px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">닫기</button>
    </div>

    <script>

        const wheelCommands = {
            stop: [{ label: 'Stop', command: 'Stop', value: 0.0 }],
            forward: [
                { label: 'Forward 1m', command: 'MoveDelta', value: 1.0 },
                { label: 'Forward 2m', command: 'MoveDelta', value: 2.0 },
            ],
            backward: [
                { label: 'Backward 1m', command: 'MoveDelta', value: -1.0 },
                { label: 'Backward 2m', command: 'MoveDelta', value: -2.0 },
            ],
            left: [
                { label: 'Left 90°', command: 'TurnDelta', value: 1.5708 },
            ],
            right: [
                { label: 'Right 90°', command: 'TurnDelta', value: -1.5708 },
            ],
        };
        

        let socket; // WebSocket 객체
        
        // WebSocket 데이터 관리
        let newRobotData = [];
        let mqtt_data = [];
        let nav2_data = [];
        let selectedRobotId = null;
        let selectedPathId;
        const robotMarkers = {};
        let robotname;

        // Waypoint 데이터를 저장할 변수
        let initialLatLngs = {};
        let initialYaws = {};


        // WebSocket 연결 설정
        function connectWebSocket() {
            const wsUrl = 'wss://c1x50yosed.execute-api.ap-northeast-2.amazonaws.com/dev'; // WebSocket 서버 URL
            socket = new WebSocket(wsUrl);

            socket.onopen = () => {
                console.log('WebSocket 연결 성공');
                const initCommand = { command: 'reload' };
                socket.send(JSON.stringify(initCommand)); // 초기화 명령 전송
            };

            // WebSocket 메시지 수신 처리
            socket.onmessage = (event) => {
                try{
                    const message = JSON.parse(event.data);
                    // console.log('Received message:', message);

                     // ACK 처리
                    if (message.request_id && ackPromises.current.has(message.request_id)) {
                        console.log(`ACK received for request_id: ${message.request_id}`);
                        const resolve = ackPromises.current.get(message.request_id);
                        if (resolve) {
                            resolve(); // Promise를 성공으로 처리
                        }
                        ackPromises.current.delete(message.request_id); // 처리된 요청 삭제
                    } else if (message.request_id) {
                        console.warn(`Unexpected ACK for request_id: ${message.request_id}`);
                    }


                
                    if (message.amr_data_db && Array.isArray(message.amr_data_db)|| message.amr_data) {
                        const tempRobotData = {};

                        // 기존 newRobotData의 내용을 tempRobotData에 복사
                        newRobotData.forEach((robot) => {
                            tempRobotData[robot.robot_id] = robot;
                        });

                        // amr_data_db가 배열인 경우 처리
                        if (Array.isArray(message.amr_data_db)) {
                            message.amr_data_db.forEach((amrData) => {
                                const robotId = amrData.data?.robot_id || null;
                                const timestamp = amrData.data?.timestamp || null;

                                if (!robotId) return; // robot_id가 없으면 무시

                                // 기존 데이터와 timestamp 비교 후 업데이트
                                if (!tempRobotData[robotId] || new Date(tempRobotData[robotId].timestamp) < new Date(timestamp)) {
                                    tempRobotData[robotId] = {
                                        connection_id: amrData.connection_id,
                                        robot_id: robotId,
                                        timestamp: timestamp,
                                    };
                                }
                            });
                        }
                        
                        // amr_data가 단일 객체인 경우 처리
                        if (message.amr_data) {
                            const amrData = message.amr_data;
                            const robotId = amrData.data?.robot_id || null;
                            const timestamp = amrData.data?.timestamp || null;

                            if (robotId) {
                                // 기존 데이터가 존재하면 connection_id 업데이트
                                if (tempRobotData[robotId]) {
                                    tempRobotData[robotId].connection_id = amrData.connection_id;
                                } else {
                                    // 새로운 robotId인 경우 추가
                                    tempRobotData[robotId] = {
                                        connection_id: amrData.connection_id,
                                        robot_id: robotId,
                                        timestamp: timestamp,
                                    };
                                }
                            }
                        }

                        // Object.values를 사용해 최종 배열 생성
                        newRobotData = Object.values(tempRobotData);

                        console.log("New Robot Data:", newRobotData);
                    } 
                    if (message.mqtt_data) {
                        const incomingData = message.mqtt_data;

                        // 기존 mqtt_data 배열 업데이트
                        const existingIndex = mqtt_data.findIndex(data => data.topic_id === incomingData.topic_id);
                        if (existingIndex !== -1) {
                            // 기존 데이터 업데이트
                            mqtt_data[existingIndex] = incomingData;
                        } else {
                            // 새로운 데이터 추가
                            mqtt_data.push(incomingData);
                        }

                         // 선택된 로봇의 데이터만 반영
                        if (incomingData.topic_id === selectedRobotId) {
                            const latitude = parseFloat(incomingData.data.fix_filtered_latitude) || 0;
                            const longitude = parseFloat(incomingData.data.fix_filtered_longitude) || 0;

                            if (incomingData.data.nav2_eta_paths) {
                                try {
                                    // JSON.parse를 사용하여 nav2_eta_path 데이터 파싱
                                    const nav2Data = JSON.parse(incomingData.data.nav2_eta_paths);

                                    // heading 값이 숫자인지 확인하고 추출 (기본값은 0)
                                    const heading = typeof nav2Data.heading === 'number' ? nav2Data.heading : 0;

                                    // 선택된 로봇 마커 위치 및 heading 업데이트
                                    updateMarkerPosition(robotname, latitude, longitude, heading);
                                } catch (error) {
                                    console.error("Error parsing nav2_eta_paths:", error);

                                    // JSON 파싱 실패 시 기본값으로 호출
                                    updateMarkerPosition(robotname, latitude, longitude, 0);
                                }
                            } else {
                                // nav2_eta_path가 없을 경우 기본값으로 호출
                                updateMarkerPosition(robotname, latitude, longitude, 0);
                            }
                        }
                        // console.log("Updated mqtt_data:", mqtt_data);
                    };

                } catch (error){
                    console.error("Error parsing message:", error);
                }
            };

            socket.onclose = () => {
                console.log('WebSocket 연결 종료');
                setTimeout(connectWebSocket, 3000); // 연결 재시도
            };

            socket.onerror = (error) => {
                console.error('WebSocket 오류:', error);
            };
        }


        let robotLayer = null;
        let waypointLayer = null;
        let map; // 전역 변수로 선언
        
        // Waypoint 데이터를 저장할 변수
        let currentPathWaypoints = [];
        let currentWaypointIndex = 0; // 현재 Waypoint의 인덱스

        function initializeMap(initialMapType = 'robot') {
            const tileUrls = {
                site: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
                robot: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'
            };

            // 선택된 맵 타입에 따른 타일 URL 설정
            const selectedUrl = tileUrls[initialMapType];

            // Leaflet 맵 초기화
            map = L.map('map').setView([37.60749551, 126.8917684], 17); 
            // OpenStreetMap 타일을 추가하여 지도에 표시
            L.tileLayer(selectedUrl, {
                maxZoom: 18,
                attribution: '© OpenStreetMap <a href="https://main.d32zil74wpx5uc.amplifyapp.com/">ZETA</a>'
            }).addTo(map);
            robotLayer = L.layerGroup().addTo(map); // WebSocket을 통해 실시간 위치를 표시할 Layer
            waypointLayer = L.layerGroup().addTo(map); // DB에서 불러온 Waypoint를 표시할 Layer
        }

        // WebSocket 연결 초기화
        document.addEventListener('DOMContentLoaded', () => {
            connectWebSocket();
            initializeMap();          
            
        });
    


        // Mobile 손가락 제어 변수 세팅
        $.Finger = {
            pressDuration: 300,
            doubleTapInterval: 300,
            flickDuration: 150,
            motionThreshold: 5
        };

        function openCustomLink() {
            const customLink = prompt("Enter the URL to open:", "https://www.example.com");
            if (customLink) {
                window.open(customLink, "_blank"); // Opens the link in a new tab
            }
        }

        


        // Reset 함수
        function resetMap() {
            
            selectedPathId = null;          

            // waypointLayer와 pathLayer에 각각의 레이어가 존재하는지 확인
            if (waypointLayer) {
                waypointLayer.clearLayers(); // 지도에서 모든 Waypoint 제거
            }
        }
    
        // 두 좌표 사이의 heading을 계산하는 함수
        function calculateHeading(startLatLng, endLatLng) {
            const dx = endLatLng.lng - startLatLng.lng;
            const dy = endLatLng.lat - startLatLng.lat;
            let angle = Math.atan2(dy, dx);

            if (angle < 0) {
                angle += 2 * Math.PI;
            }

            return angle;
        }


        // 로봇 원격 제어 팝업 함수
        function robotController() {
            if (selectedRobotId === null) {
                alert("No robots selected.");
                return;
            }
            
            document.getElementById('controllerPopup').style.display = 'flex';
        }

        // 로봇 조작 명령을 WebSocket으로 전송
        function sendControl(command) {

            if (!selectedRobotId) {
                console.error("선택된 로봇이 없습니다.");
                return;
            }

            // connectionId 가져오기
            const connectionId = getConnectionId(newRobotData,selectedRobotId);

            if (!connectionId) {
                console.error("Connection ID가 없습니다. WebSocket 연결을 확인하세요.");
                return;
            }

            // wheelCommands에서 command 매핑
            const matchedCommand = wheelCommands[command]?.[0];
            if (!matchedCommand) {
                console.error(`유효하지 않은 명령: ${command}`);
                return;
            }

            const { command: commandType, value } = matchedCommand;

            const uuidv4 = (() => {
                    // UUID 생성 로직 간단 구현
                    return () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const r = (Math.random() * 16) | 0;
                    const v = c === 'x' ? r : (r & 0x3) | 0x8;
                    return v.toString(16);
                    });
                })();
            
            // 데이터 구조 생성
            const messageData = {
                type: "system",
                args: {
                    command: "wheel_control",
                    connection_id: connectionId,
                    robot_id: selectedRobotId,
                    value: value, // wheelCommands에서 가져온 값
                    function: commandType, // wheelCommands에서 가져온 명령 유형
                    request_id: uuidv4() // 유니크한 ID 생성
                }
            };

            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(messageData));
                console.log(`명령 전송: ${JSON.stringify(messageData)}`);
            } else {
                console.error("WebSocket 연결이 닫혀있습니다.");
            }
        }

        // 로봇 원격 제어 팝업 닫는 함수
        function closeControllerPopup() {
            document.getElementById('controllerPopup').style.display = 'none';
        }

        function getConnectionId(newRobotData, selectedRobotId) {
            // selectedRobotId와 매칭되는 connectionId 찾기
            const matchedData = newRobotData.find(data =>
                data.robot_id && // null 또는 undefined가 아닌 경우에만 실행
                data.robot_id.trim().toLowerCase() === selectedRobotId.trim().toLowerCase()
            );

            // connectionId가 존재하면 반환, 없으면 null 반환
            return matchedData ? matchedData.connection_id : null;
        }


        // ==================================================================
        //
        //                    로봇 세팅 및 상태 시각화 함수
        //
        // ==================================================================

        // 팝업 열기
        async function openRobotListPopup() {
            const robotListPopup = document.getElementById('robotListPopup');
            const robotList = document.getElementById('robotList');
            robotList.innerHTML = ''; // 기존 항목 초기화

            // Supabase에서 데이터 가져오기
            const robots = await fetchRobotData();

            // WebSocket의 currentMqttData와 연결 상태를 확인
            robots.forEach(robot => {
                const matchedData = newRobotData.find(data => 
                data.robot_id && // null 또는 undefined가 아닌 경우에만 실행
                data.robot_id.trim().toLowerCase() === robot.robotId.trim().toLowerCase()
            );
                const connectionId = matchedData ? matchedData.connection_id : null;

                 // 연결되지 않은 로봇은 선택 불가 처리
                const li = document.createElement('li');
                li.style = `
                    padding: 10px; 
                    background-color: ${connectionId ? '#d4f8d4' : '#f9d4d4'}; 
                    border: 1px solid #ddd; 
                    border-radius: 10px; 
                    margin-bottom: 10px; 
                    font-size: 1rem; 
                    display: flex; 
                    justify-content: space-between; 
                    align-items: center;
                    cursor: ${connectionId ? 'pointer' : 'not-allowed'};
                `;
                li.innerHTML = `
                    <span>
                        <strong>Robot Name:</strong> ${robot.name} (${robot.robotId})<br>
                        <strong>Connection ID:</strong> ${connectionId || 'No Connection'}
                    </span>
                `;

                robotList.appendChild(li);

                // 연결된 로봇만 선택 가능
                if (connectionId) {
                    li.onclick = () => selectRobot(robot.name, robot.robotId, connectionId);
                }

            });

            // 닫기 버튼 추가 및 스타일 적용
            const closeButton = document.createElement('button');
            closeButton.innerText = 'Close';
            closeButton.style = `
                position: absolute;
                top: 10px;
                right: 10px;
                padding: 10px 20px;
                font-size: 1.2rem;
                color: white;
                background-color: #ff5555; /* 닫기 버튼 색상 */
                border: none;
                border-radius: 5px;
                cursor: pointer;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            `;

            closeButton.onclick = closeRobotListPopup;


            
            robotListPopup.appendChild(closeButton);
            // 팝업 보이기
            robotListPopup.style.display = 'block';

            // 팝업이 화면 크기에 맞게 조정되도록 설정
            const popupWidth = Math.min(window.innerWidth * 0.9, 600); // 최대 너비 600px
            const popupHeight = Math.min(window.innerHeight * 0.8, 600); // 최대 높이 80%
            robotListPopup.style.width = `${popupWidth}px`;
            robotListPopup.style.height = `${popupHeight}px`;
        }

        // 팝업 닫기
        function closeRobotListPopup() {
            const robotListPopup = document.getElementById('robotListPopup');
            robotListPopup.style.display = 'none';
        }

        async function fetchRobotData() {
            try {
                const { data: robots, error } = await supabase
                    .from('Robot') // 테이블 이름
                    .select('robotId, name'); // 필요한 컬럼만 선택

                if (error) {
                    console.error('Error fetching robots:', error);
                    return [];
                }

                return robots || [];
            } catch (error) {
                console.error('Unexpected error:', error);
                return [];
            }
        }

        function handleRobotSelectionChange() {
            const dropdown = document.getElementById('selectedRobotDropdown');
            selectedRobotId = dropdown.value;

            // mqtt_data에서 로봇 데이터 찾기
            const selectedRobotData = mqtt_data.find(data => data.topic_id === selectedRobotId);

            if (!selectedRobotData || !selectedRobotData.data) {
                alert('Unable to find data for the selected robot.');
                return;
            }

            // 로봇 이름 업데이트
            const selectedOption = dropdown.options[dropdown.selectedIndex];
            if (selectedOption) {
                robotname = selectedOption.textContent.split('(')[0].trim(); // 이름만 추출
            }

            // 로봇 위치 데이터 가져오기
            const latitude = parseFloat(selectedRobotData.data.fix_filtered_latitude) || 0;
            const longitude = parseFloat(selectedRobotData.data.fix_filtered_longitude) || 0;
            

            if (latitude === 0 && longitude === 0) {
                alert('Invalid location data for the selected robot.');
                return;
            }

            // 지도 업데이트
            updateMap(latitude, longitude, robotname);
        }

        

        function selectRobot(name, robotId, connectionId) {
            const dropdown = document.getElementById('selectedRobotDropdown');
            selectedRobotId = dropdown.value;
            

            // 중복 추가 방지
            const exists = Array.from(dropdown.options).some(option => option.value === robotId);
            if (exists) {
                alert('This robot is already selected!');
                return;
            }

            // 드롭다운에 로봇 추가
            const option = document.createElement('option');
            option.value = robotId;
            option.textContent = `${name} (${robotId})`;
            robotname = name;
            dropdown.appendChild(option);


            // mqtt_data에서 로봇 위치 찾기
            const selectedRobotData = mqtt_data.find(data => String(data.topic_id).trim().toLowerCase() === String(robotId).trim().toLowerCase());
            if (!selectedRobotData) {
                alert('Unable to find robot location data!');
                return;
            }

            const latitude = parseFloat(selectedRobotData.data.fix_filtered_latitude) || 0;
            const longitude = parseFloat(selectedRobotData.data.fix_filtered_longitude) || 0;
            // const heading = selectedNav2Data.heading || 0; // heading 값 가져오기

            // 지도 업데이트
            updateMap(latitude, longitude, name);

            // 팝업 닫기
            closeRobotListPopup();
        }

        // 지도 업데이트 함수
        function updateMap(latitude, longitude, name) {
            if (!map) {
                console.error("Map is not initialized!");
                return;
            }

            // 선택된 로봇의 마커 업데이트
            // updateMarkerPosition(name, latitude, longitude);

            // 지도 중심 이동
            map.setView([latitude, longitude], 17);
        }

        function updateMarkerPosition(robotname, latitude, longitude, heading=0) {
            if (!robotLayer) {
                console.error("Robot layer is not initialized!");
                return;
            }

             // 로봇 이름에 따른 색상 지정
            const robotColor = (() => {
                switch (robotname.toLowerCase()) {
                    case 'yellow': return 'yellow';
                    case 'tank orange': return 'orange';
                    case 'blue': return '#1E90FF';
                    case 'tank purple': return 'purple';
                    case 'pink': return 'pink';
                    default: return 'green'; // 기본 색상
                }
            })();

            // 화살표 아이콘 생성 함수
            const createArrowIcon = (color) => {

                const headingInDegrees = (heading * 180) / Math.PI; // 라디안 -> 각도 변환
                const adjustedHeading = (360 - headingInDegrees) % 360; // 시계 방향으로 회전 조정
                
                
                return L.divIcon({
                    html: `<div class="transform" style="color: ${color}; font-size: 18px; transform: rotate(${adjustedHeading}deg);">➤</div>`,
                    className: 'arrow-icon',
                    iconSize: [24, 24], // 아이콘 크기
                });
            };

             // 기존 마커가 존재하면 위치 업데이트
            if (robotMarkers[robotname]) {
                robotMarkers[robotname].setLatLng([latitude, longitude]);
                robotMarkers[robotname].setIcon(createArrowIcon(robotColor));
                robotMarkers[robotname].setZIndexOffset(1000); // z-index 설정
            } else {
                // 새 마커 생성
                const marker = L.marker([latitude, longitude], { icon: createArrowIcon(robotColor) }).addTo(robotLayer)
                // marker.bindPopup(`<strong>Robot:</strong> ${robotname}`).openPopup();

                // 마커를 robotMarkers에 저장
                robotMarkers[robotname] = marker;
            }

            // 다른 로봇의 마커는 제거
            Object.keys(robotMarkers).forEach(id => {
                if (id !== robotname) {
                    robotLayer.removeLayer(robotMarkers[id]); // 지도에서 제거
                    delete robotMarkers[id]; // robotMarkers 객체에서 제거
                }
            });
        }

         // DB Robot 팝업 열기 및 데이터 조회 함수
         async function openDBRobotPopup() {
            await fetchRobotList(); // 로봇 목록 조회 후 팝업 열기
        }

        // DB Robot 팝업 닫기 함수
        function closeDBRobotPopup() {
            document.getElementById("dbRobotPopup").style.display = "none"; // 팝업 숨기기
        }

        // 첫 번째 팝업에서 로봇 목록을 클릭하면 Path 목록을 표시하는 팝업을 띄움
        async function fetchRobotList() {
            try {
                if (!selectedRobotId) {
                    alert("Please select a robot from the dropdown.");
                    return;
                }

                // Supabase에서 Robot 테이블 조회
                const { data: robots, error } = await supabase.from('Robot').select('id, robotId, name').order('id', { ascending: true });

                if (error) {
                    console.error('Robot 조회 오류:', error);
                    return;
                }

                // SelectedRobotId와 일치하는 로봇 찾기
                const selectedRobot = robots.find(robot => robot.robotId === selectedRobotId);

                if (!selectedRobot) {
                    alert("Selected robot not found in the database.");
                    return;
                }

                // Path 목록 팝업 열기
                openPathListPopup(selectedRobot.id); // 로봇 ID 전달
            } catch (error) {
                console.error("Unexpected error:", error);
            }
        }     

        // Path 목록을 표시하는 함수 (로봇 ID를 인자로 받음)
        async function openPathListPopup(robotId) {
            selected_RobotId = robotId;
            const pathListDisplay = document.getElementById("pathListDisplay");
            pathListDisplay.innerHTML = ""; // 기존 목록 초기화

            try {
                const { data: paths, error } = await supabase
                    .from('Path')
                    .select('id, name')
                    .eq('robotId', robotId) // 로봇 ID에 해당하는 Path만 조회
                    .order('id', { ascending: true });

                if (error) {
                    console.error('Path 목록 조회 오류:', error);
                    return;
                }

                paths.forEach(path => {
                // Path 항목 컨테이너
                const pathItem = document.createElement("div");
                pathItem.style = `
                    display: flex; 
                    align-items: center; 
                    justify-content: space-between; 
                    padding: 10px; 
                    background-color: #e0f7fa; 
                    border: 1px solid #00796b; 
                    border-radius: 5px; 
                    margin-bottom: 5px; 
                    cursor: pointer;
                `;

                // Path 이름 표시
                const pathName = document.createElement("div");
                pathName.innerHTML = `<strong>Path Name:</strong> ${path.name}`;
                pathName.style = "flex-grow: 1; cursor: pointer;";
                pathName.onclick = () => {
                    selectedPathId = path.id; // 선택된 Path ID 저장
                    closePathListPopup(); // 팝업 닫기
                    loadWaypointsFromDatabase(path.id);
                };

                // Add Waypoint 버튼
                const addWaypointButton = document.createElement("button");
                addWaypointButton.innerText = "+Add Waypoint";
                addWaypointButton.style = `
                    background: none; 
                    border: none; 
                    font-size: 14px; 
                    color: #007bff; 
                    cursor: pointer; 
                    margin-right: 10px;
                `;
                addWaypointButton.onclick = (e) => {
                    e.stopPropagation(); // Path 클릭 이벤트 중지
                    closePathListPopup(); // 팝업 닫기
                    loadWaypointsFromDatabase(path.id)
                    enableAddWaypointMode(path.id);
                };

                // 삭제 버튼 (X 아이콘)
                const deleteButton = document.createElement("button");
                deleteButton.innerHTML = "&#10006;"; // 유니코드 X 아이콘
                deleteButton.style = `
                    color: white; 
                    background-color: red; 
                    border: none; 
                    border-radius: 50%; 
                    width: 24px; 
                    height: 24px; 
                    font-size: 16px; 
                    cursor: pointer; 
                    display: flex; 
                    align-items: center; 
                    justify-content: center;
                `;
                deleteButton.onclick = (e) => {
                    e.stopPropagation(); // Path 클릭 이벤트 중지
                    deletePath(path.id, pathItem); // Path 삭제 함수 호출
                };

                // Path 항목에 요소 추가
                pathItem.appendChild(pathName);
                pathItem.appendChild(addWaypointButton);
                pathItem.appendChild(deleteButton);

                pathListDisplay.appendChild(pathItem);
            });

            document.getElementById("pathListPopup").style.display = "block"; // 팝업 열기

        } catch (error) {
            console.error("Path 목록 불러오기 오류:", error);
        }
        }

        async function deletePath(pathId, pathElement) {
            const confirmDelete = confirm("Are you sure you want to delete this Path?");
            if (!confirmDelete) {
                return;
            }

            try {

                const { error: waypointError } = await supabase
                    .from('Waypoint')
                    .delete()
                    .eq('pathId', pathId);

                if (waypointError) {
                console.error("Waypoint 삭제 중 오류 발생:", waypointError);
                return;
                }

                const { error } = await supabase
                    .from('Path')
                    .delete()
                    .eq('id', pathId);

                if (error) {
                    console.error("Error deleting Path:", error);
                    alert("Failed to delete Path. Please try again.");
                    return;
                }

                alert("Path deleted successfully.");
                pathElement.remove(); // UI에서 Path 제거
            } catch (error) {
                console.error("Unexpected error while deleting Path:", error);
            }
        }

        // 새로운 Path를 추가할 수 있는 폼을 표시하는 함수
        function openAddPathPopup() {
            const addPathPopup = document.createElement('div');
            addPathPopup.id = 'newPathPopup';  // ID를 추가하여 팝업 닫기 함수에서 찾을 수 있도록 설정
            addPathPopup.style = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 90%;
                max-width: 300px;
                padding: 20px;
                background-color: #ffffff;
                border-radius: 8px;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
                font-size: 14px;
                z-index: 1000;
            `;

            addPathPopup.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3 style="margin: 0; font-size: 18px;">Add New Path</h3>
                    <button onclick="closeAddPathPopup()" style="background: none; border: none; font-size: 20px; font-weight: bold; cursor: pointer;">&times;</button>
                </div>
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    <label>Description:</label>
                    <input type="text" id="newPathDescription" placeholder="Enter Description" style="padding: 8px; border: 1px solid #ddd; border-radius: 5px; font-size: 14px;"/>
                    
                    <label>Type:</label>
                    <input type="text" id="newPathType" placeholder="Enter Type" style="padding: 8px; border: 1px solid #ddd; border-radius: 5px; font-size: 14px;"/>
                </div>
                <div style="display: flex; justify-content: space-between; margin-top: 15px;">
                    <button onclick="addNewPath()" style="width: 48%; padding: 10px; font-size: 16px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">Save</button>
                    <button onclick="closeAddPathPopup()" style="width: 48%; padding: 10px; font-size: 16px; background-color: #f8f9fa; color: black; border: 1px solid #ddd; border-radius: 5px; cursor: pointer;">Cancel</button>
                </div>
            `;

            document.body.appendChild(addPathPopup);
        }

        // 새로운 Path 데이터를 Supabase DB에 추가하는 함수
        async function addNewPath() {
            const description = document.getElementById("newPathDescription").value;
            const type = document.getElementById("newPathType").value;

            if (!description || !type) {
                alert("Description과 Type을 모두 입력하세요.");
                return;
            }

            const { data: robotData, error: robotError } = await supabase
                .from('Robot') // Robot 테이블에서
                .select('id')  // id만 선택
                .eq('robotId', selectedRobotId) // selectedRobotId와 매칭되는 데이터 찾기
                .single(); // 단일 행만 반환

            if (robotError || !robotData) {
                console.error('Robot 정보 조회 오류:', robotError);
                return;
            }

            const robotDbId = robotData.id; // Robot 테이블의 id 값

            const { error } = await supabase.from('Path').insert([{ 
                robotId: robotDbId, 
                name: "New Path", 
                description: description, 
                color: "gray", 
                type: type 
            }]);

            if (error) {
                console.error("Path 추가 오류:", error);
                alert("Path 추가에 실패했습니다.");
            } else {
                alert("새로운 Path가 추가되었습니다.");
                closeAddPathPopup();
                loadPathList(selectedRobotId); // Path 목록 갱신
            }
        }

        // Path 추가 팝업 닫기 함수
        function closeAddPathPopup() {
            const addPathPopup = document.querySelector('#newPathPopup');
            if (addPathPopup) {
                document.body.removeChild(addPathPopup);
            }
        }

        
        // 첫 번째 팝업 닫기 함수
        function closeDBRobotPopup() {
            document.getElementById("dbRobotPopup").style.display = "none"; // 첫 번째 팝업 숨기기
        }

        // 두 번째 팝업 닫기 함수
        function closePathListPopup() {
            document.getElementById("pathListPopup").style.display = "none"; // 두 번째 팝업 숨기기
        }

        // DB에서 모든 Waypoint를 불러와 한 번에 전송하는 함수
        async function sendAllWaypoints(pathId,commandType = 0, reverse = false) {

            if (!socket || socket.readyState !== WebSocket.OPEN) {
                console.error("WebSocket 연결이 열려 있지 않습니다. 연결을 재설정합니다.");
                alert("WebSocket 연결이 닫혀 있습니다. 다시 시도해 주세요.");
                return;
            }

            if (!selectedRobotId) {
                alert("로봇을 선택해주세요.");
                return;
            }

            if (!pathId) {
                alert("Path를 선택해주세요.");
                return;
            }

            try {
                // Supabase에서 Waypoint 데이터를 불러오기
                const { data: waypoints, error } = await supabase
                    .from('Waypoint')
                    .select('latitude, longitude, name, type, yaw')
                    .eq('pathId', pathId)
                    .order('id', { ascending: true });

                if (error) {
                    console.error('Waypoint 데이터 조회 오류:', error);
                    return;
                }

                if (waypoints.length === 0) {
                    alert("선택된 Path에 Waypoint가 없습니다.");
                    return;
                }

                // connection_id 찾기
                const matchedRobotData = newRobotData.find(data =>
                    String(data.robot_id).trim().toLowerCase() === String(selectedRobotId).trim().toLowerCase()
                );

                if (!matchedRobotData || !matchedRobotData.connection_id) {
                    alert("선택된 로봇에 대한 연결 정보를 찾을 수 없습니다.");
                    return;
                }

                const connectionId = matchedRobotData.connection_id;
                let pathData ={};

                const uuidv4 = (() => {
                    // UUID 생성 로직 간단 구현
                    return () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const r = (Math.random() * 16) | 0;
                    const v = c === 'x' ? r : (r & 0x3) | 0x8;
                    return v.toString(16);
                    });
                })();
                const requestId = uuidv4();

                if(reverse){
                    handleReversePath(waypoints,connectionId,pathId,commandType, requestId)
                   
                } else{
                    // WebSocket 데이터 구조 생성
                    pathData = {
                        type: "system",
                        args: {
                            command: "path",
                            connection_id: connectionId,
                            robot_id: selectedRobotId,
                            path_id: pathId,
                            waypoint_id: -1,
                            type: commandType,
                            request_id: requestId, // request_id 추가
                        },
                    };
                    console.log("전송할 WebSocket 데이터:", JSON.stringify(pathData, null, 2));
                    socket.send(JSON.stringify(pathData));
                }
                return;

            } catch (error) {
                console.error("Unexpected error while loading waypoints from database:", error);
            }
        }

        async function handleReversePath(waypoints, connectionId, pathId, commandType, requestId) {
            try {
                if (!waypoints || waypoints.length === 0) {
                    console.error("Reverse 처리할 Waypoints가 없습니다.");
                    return;
                }

                // 기존 Path 이름 가져오기
                const { data: existingPathData, error: existingPathDataError } = await supabase
                    .from('Path')
                    .select('name')
                    .eq('id', pathId)
                    .single();

                if (existingPathDataError || !existingPathData) {
                    console.error('기존 Path 이름 조회 오류:', existingPathDataError);
                    return;
                }

                const originalPathName = existingPathData.name;

                // Reverse Path 이름 생성
                const reversePathName = `${originalPathName}_reverse`;

                const { data: robotData, error: robotError } = await supabase
                    .from('Robot') // Robot 테이블에서
                    .select('id')  // id만 선택
                    .eq('robotId', selectedRobotId) // selectedRobotId와 매칭되는 데이터 찾기
                    .maybeSingle();

                if (robotError || !robotData) {
                    console.error('Robot 정보 조회 오류:', robotError);
                    return;
                }

                const robotDbId = robotData.id; // Robot 테이블의 id 값

                // Reverse Path 중복 확인
                const { data: existingReversePath, error: existingReversePathError } = await supabase
                    .from('Path')
                    .select('id')
                    .eq('name', reversePathName)
                    .eq('robotId', robotDbId) // 선택된 로봇에 해당하는 Path만 확인
                    .maybeSingle();

                if (existingReversePathError) {
                    console.error('Reverse Path 중복 확인 중 오류 발생:', existingReversePathError);
                    return;
                }

                if (existingReversePath) {
                    alert(`Reverse Path "${reversePathName}"가 이미 선택된 로봇에 존재합니다. 새로 생성하지 않습니다.`);
                    return;
                }

                let newPathId = null;

                // Reverse Waypoints 처리
                const reversedWaypoints = [...waypoints] // 원본 배열을 복사
                    .reverse() // 복사된 배열을 반대로 정렬
                    .map(wp => ({
                        ...wp,
                        yaw: (wp.yaw + Math.PI) % (2 * Math.PI), // 방향 반대로 계산
                    }));

                // Reverse Path 생성
                const { data: newPath, error: pathError } = await supabase
                    .from('Path')
                    .insert({
                        name: reversePathName,
                        robotId: robotDbId,
                        description: "Automatically generated reverse path",
                        color: "blue", // 필요 시 색상 지정
                        type: 0 // Path 타입 지정
                    })
                    .select();

                if (pathError || !newPath) {
                    console.error('Reverse Path 생성 오류:', pathError);
                    return;
                }

                newPathId = newPath[0].id;

                // Reverse Waypoints를 새로운 Path에 추가
                const waypointData  = reversedWaypoints.map(wp =>({
                    pathId: newPathId,
                    latitude: wp.latitude,
                    longitude: wp.longitude,
                    yaw: wp.yaw,
                    name: wp.name,
                    type: wp.type,
                    color: wp.color || "blue" // 필요 시 색상 지정
                }));

                const { data: waypointInsertions, error: waypointError } = await supabase.from('Waypoint').insert(waypointData);

                if (waypointError) {
                    console.error("Reverse Waypoint 삽입 중 오류 발생:", waypointError);
                    return;
                }                

                console.log("Reverse Path와 Waypoints가 성공적으로 생성되었습니다.");
                return;


                
            } catch (error) {
                console.error("Reverse Path 처리 중 예기치 않은 오류 발생:", error);
            }
        }

        function openRobotSelectionPopup() {
            // Supabase에서 모든 로봇 리스트 가져오기
            supabase
                .from('Robot')
                .select('id, robotId, name')
                .order('id', { ascending: true })
                .then(({ data: robots, error }) => {
                    if (error) {
                        console.error('Error fetching robots:', error);
                        alert('Failed to load robots.');
                        return;
                    }

                    const popup = document.createElement('div');
                    popup.id = 'robotSelectionPopup';
                    popup.style = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        width: 90%;
                        background: white;
                        border: 1px solid black;
                        padding: 20px;
                        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                        z-index: 1000;
                        max-width: 400px;
                        max-height: 400px;
                        display: flex;
                        flex-direction: column;
                    `;

                    popup.innerHTML = `
                        <!-- 상단 영역 -->
                        <div style="position: relative; flex-shrink: 0;">
                            <!-- 닫기 버튼 -->
                            <button onclick="closePopup('robotSelectionPopup')" 
                                style="
                                    position: absolute; 
                                    top: 10px; 
                                    right: 10px; 
                                    background: none; 
                                    border: none; 
                                    font-size: 20px; 
                                    font-weight: bold; 
                                    cursor: pointer;">
                                &times;
                            </button>

                            <!-- 제목 -->
                            <h3 style="margin: 0; text-align: center;">Select a Robot</h3>
                        </div>

                        <!-- 스크롤 가능한 로봇 리스트 -->
                        <div style="flex: 1; overflow-y: auto; margin-top: 15px; padding-right: 5px;">
                            <ul style="list-style: none; padding: 0; margin: 0;">
                                ${robots
                                    .map(
                                        robot => `
                                        <li style="margin: 10px 0; cursor: pointer; padding: 10px; background: #f9f9f9; border: 1px solid #ddd;" 
                                            onclick="fetchPathList(${robot.id}, '${robot.name}')">
                                            <strong>${robot.name}</strong> (${robot.robotId})
                                        </li>
                                    `
                                    )
                                    .join('')}
                            </ul>
                        </div>

                        <!-- 하단 취소 버튼 -->
                        <button style="margin-top: 15px; padding: 10px; background: red; color: white; border: none; cursor: pointer; width: 100%; border-radius: 5px; flex-shrink: 0;" 
                            onclick="closePopup('robotSelectionPopup')">Cancel</button>
                    `;

                    document.body.appendChild(popup);
                });
        }

        function closePopup(popupId) {
            const popup = document.getElementById(popupId);
            if (popup) {
                document.body.removeChild(popup);
            }
        }

        function fetchPathList(robotId, robotName) {
            closePopup('robotSelectionPopup'); // 이전 팝업 닫기

            supabase
                .from('Path')
                .select('id, name, description')
                .eq('robotId', robotId)
                .order('id', { ascending: true })
                .then(({ data: paths, error }) => {
                    if (error) {
                        console.error('Error fetching paths:', error);
                        alert('Failed to load paths.');
                        return;
                    }

                    // Path 리스트 팝업 생성
                    const popup = document.createElement('div');
                    popup.id = 'pathSelectionPopup';
                    popup.style = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        width: 90%;
                        background: white;
                        border: 1px solid black;
                        padding: 20px;
                        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                        z-index: 1000;
                        max-width: 400px;
                        max-height: 400px;
                        display: flex;
                        flex-direction: column;
                    `;

                    popup.innerHTML = `
                        <!-- 상단 영역 -->
                        <div style="position: relative; flex-shrink: 0;">
                            <!-- 뒤로 가기 버튼 -->
                            <button onclick="openRobotSelectionPopup()" 
                                style="
                                    background: none; 
                                    border: none; 
                                    font-size: 14px; 
                                    color: #007bff; 
                                    cursor: pointer;">
                                &#8592; Back
                            </button>
                            <!-- 제목 -->
                            <h3 style="margin: 0; text-align: center;">Select a Path to Clone</h3>
                            <!-- 닫기 버튼 -->
                            <button onclick="closePopup('pathSelectionPopup')" 
                                style="
                                    position: absolute; 
                                    top: 10px; 
                                    right: 10px; 
                                    background: none; 
                                    border: none; 
                                    font-size: 20px; 
                                    font-weight: bold; 
                                    cursor: pointer;">
                                &times;
                            </button>
                        </div>

                        <!-- 스크롤 가능한 Path 리스트 -->
                        <div style="flex: 1; overflow-y: auto; margin-top: 15px; padding-right: 5px;">
                            <ul style="list-style: none; padding: 0; margin: 0;">
                                ${paths
                                    .map(
                                        path => `
                                        <li style="margin: 10px 0; cursor: pointer; padding: 10px; background: #f9f9f9; border: 1px solid #ddd;">
                                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                                <div>
                                                    <strong>${path.name}</strong><br>
                                                    <small>${path.description}</small>
                                                </div>
                                                <div>
                                                    <button onclick="previewPath('${path.id}')" 
                                                        style="margin-right: 10px; padding: 5px 10px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">Preview</button>
                                                    <button onclick="clonePath('${path.id}', '${path.name}', '${path.description}', '${robotName}')" 
                                                        style="padding: 5px 10px; background-color: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer;">Clone</button>
                                                </div>
                                            </div>
                                        </li>
                                    `
                                    )
                                    .join('')}
                            </ul>
                        </div>

                        <!-- 하단 Cancel 버튼 -->
                        <button onclick="closePopup('pathSelectionPopup')" 
                            style="margin-top: 15px; padding: 10px; background: red; color: white; border: none; cursor: pointer; width: 100%; border-radius: 5px; flex-shrink: 0;">
                            Cancel
                        </button>
                    `;

                    document.body.appendChild(popup);
                });
        }

        async function clonePath(pathId, pathName, pathDescription, sourceRobotName) {
            closePopup('pathSelectionPopup'); // 이전 팝업 닫기

            if (!selectedRobotId) {
                alert('Please select a robot to clone the path to.');
                return;
            }

            try {
                // 현재 로봇 정보 가져오기
                const { data: currentRobot, error: currentRobotError } = await supabase
                    .from('Robot')
                    .select('id')
                    .eq('robotId', selectedRobotId)
                    .single();

                if (currentRobotError) {
                    console.error('Error fetching current robot data:', currentRobotError);
                    alert('Failed to fetch the current robot data.');
                    return;
                }

                const currentRobotId = currentRobot.id;

                // 선택된 Path의 Waypoints 가져오기
                const { data: waypoints, error: waypointError } = await supabase
                    .from('Waypoint')
                    .select('*')
                    .eq('pathId', pathId)
                    .order('id', { ascending: true }); // 오름차순 정렬

                console.log('Inserted waypoints:', waypoints);

                if (waypointError) {
                    console.error('Error fetching waypoints:', waypointError);
                    return;
                }

                // Path 복제
                const { data: newPath, error: newPathError } = await supabase
                    .from('Path')
                    .insert({
                        robotId: currentRobotId,
                        name: `${sourceRobotName}_${pathName}_clone`,
                        description: pathDescription,
                        color: 'gray', // 기본 색상
                        type: 0, // 기본 타입
                    })
                    .select()
                    .single();

                if (newPathError) {
                    console.error('Error cloning path:', newPathError);
                    alert('Failed to clone the path.');
                    return;
                }

                // Waypoints 복제
                const clonedWaypoints = waypoints.map(wp => ({
                    pathId: newPath.id,
                    latitude: wp.latitude,
                    longitude: wp.longitude,
                    yaw: wp.yaw,
                    name: wp.name,
                    type: wp.type,
                    color: wp.color,
                }));

                const { error: waypointCloneError } = await supabase
                    .from('Waypoint')
                    .insert(clonedWaypoints);

                if (waypointCloneError) {
                    console.error('Error cloning waypoints:', waypointCloneError);
                    alert('Failed to clone the waypoints.');
                    return;
                }

                alert('Path successfully cloned!');
                waypointLayer.clearLayers();

            } catch (error) {
                console.error('Unexpected error cloning path:', error);
                alert('An unexpected error occurred while cloning the path.');
            }
        }

        function displayPathOnMap(waypoints) {
            // 지도 초기화
            if (!map) {
                alert('Map is not initialized!');
                return;
            }

            // 기존 Path 레이어 제거
            if (waypointLayer) {
                waypointLayer.clearLayers();
            }

             // Waypoints를 지도에 표시
            const latlngs = waypoints.map(wp => [wp.latitude, wp.longitude]);
            L.polyline(latlngs, { color: 'blue', weight: 5 }).addTo(waypointLayer); // 경로 표시

            waypoints.forEach(wp => {
                // Custom 마커 생성
                const customIcon = L.divIcon({
                    className: 'custom-div-icon',
                    html: `<img src="arrow.png" alt="Waypoint Icon" style="transform: rotate(${2 * Math.PI - wp.yaw}rad);"/>`,
                    iconSize: [10, 10], // 아이콘 크기 조정
                });

                // Custom 마커 추가
                L.marker([wp.latitude, wp.longitude], { icon: customIcon })
                    .bindPopup(`<strong>${wp.name}</strong><br>Type: ${wp.type}`)
                    .addTo(waypointLayer); // 웨이포인트 마커 추가
            });

            // 지도를 Waypoints 범위에 맞게 줌
            const bounds = L.latLngBounds(latlngs);
            map.fitBounds(bounds);
        }

        function previewPath(pathId) {
             // 팝업 숨기기
            const popup = document.getElementById('pathSelectionPopup');
            if (popup) {
                popup.style.visibility = 'hidden'; // 팝업 숨기기
            }

            // 이미 존재하는 복원 버튼 제거
            const existingRestoreButton = document.getElementById('restoreButton');
            if (existingRestoreButton) {
                document.body.removeChild(existingRestoreButton);
            }

            // Waypoints 데이터 가져오기
            supabase
                .from('Waypoint')
                .select('*')
                .eq('pathId', pathId)
                .then(({ data: waypoints, error }) => {
                    if (error) {
                        console.error('Error fetching waypoints:', error);
                        alert('Failed to load waypoints for preview.');
                        popup.style.visibility = 'hidden'; // 에러 발생 시 팝업 다시 표시
                        return;
                    }

                    if (waypoints.length === 0) {
                        alert('No waypoints available for this path.');
                        popup.style.visibility = 'hidden'; // 데이터가 없을 때 팝업 다시 표시
                        return;
                    }

                    // 지도에 Path 표시
                    displayPathOnMap(waypoints);

                    // 복원 버튼 생성
                    const restoreButton = document.createElement('button');
                    restoreButton.id = 'restoreButton'; // 복원 버튼에 ID 설정
                    restoreButton.textContent = 'Back to Path List';
                    restoreButton.style = `
                        position: fixed;
                        top: 10px;
                        left: 10px;
                        padding: 10px;
                        background: #007bff;
                        color: white;
                        border: 2px solid #0056b3;
                        border-radius: 8px;
                        font-size: 16px;
                        font-weight: bold;
                        cursor: pointer;
                        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
                        transition: background 0.3s ease, transform 0.2s ease;
                        z-index: 1001;
                    `;
                    restoreButton.onclick = () => {
                        popup.style.visibility = 'hidden' // 팝업 다시 표시
                        document.body.removeChild(restoreButton); // 복원 버튼 제거
                        waypointLayer.clearLayers(); // 지도에서 Waypoints 제거
                    };

                    document.body.appendChild(restoreButton);
                });
        }



        // Waypoint 데이터를 불러와 지도에 표시하는 함수
        async function loadWaypointsFromDatabase(pathId) {
            waypointLayer.clearLayers(); // 기존 Waypoint 마커 제거
            currentPathWaypoints = []; // 새로운 경로로 초기화

            try {
                const { data: waypoints, error } = await supabase
                    .from('Waypoint')
                    .select('id, latitude, longitude, name, type, yaw, color')
                    .eq('pathId', pathId)
                    .order('id', { ascending: true }); // Name 기준 오름차순으로 정렬

                if (error) {
                    console.error('Waypoint 데이터 조회 오류:', error);
                    return;
                }
                waypoints.forEach((waypoint, index) => {
                    console.log(`Waypoint ${index}: Name=${waypoint.name}, Latitude=${waypoint.latitude}, Longitude=${waypoint.longitude}`);
                });

                currentPathWaypoints = waypoints; // 현재 경로의 Waypoints를 저장

                waypoints.forEach((waypoint, index) => {
                    const { id, latitude, longitude, name, type, yaw } = waypoint;
                    const latlng = [latitude, longitude];
                    

                    const marker = L.marker(latlng, {
                        title: name,
                        icon: L.divIcon({
                            className: 'custom-div-icon',
                            html: `<img src="arrow.png" alt="Waypoint Icon" style="transform: rotate(${2*Math.PI-yaw}rad);"/>`,
                            iconSize: [10, 10],
                        }),
                        draggable: false,
                    }).addTo(waypointLayer);

                    // 마커 클릭 시 Waypoint 정보 표시
                    marker.on('click', () => showWaypointInfoPopup(id, latlng, name, latitude, longitude, yaw, type));

                    // Waypoints 간의 선 연결
                    if (index > 0) {
                        const previousLatLng = [waypoints[index - 1].latitude, waypoints[index - 1].longitude];
                        const currentDistance = map.distance(previousLatLng, latlng); // 두 점 사이 거리 계산
                        
                        // 거리 기준 초과 시 로그 출력
                        if (currentDistance > 100) { // 예: 100m 이상이면 경고
                            console.warn(`Unusual distance between waypoints ${waypoints[index - 1].id} and ${id}: ${currentDistance} meters`);
                        }

                        const polyline = L.polyline([previousLatLng, latlng], { color: '#808080' }).addTo(waypointLayer); // 회색으로 통일
                    }
                });
            } catch (error) {
                console.error("Unexpected error while loading waypoints from database:", error);
            }
        }

        // Waypoint 정보 표시 팝업 생성 함수
        function showWaypointInfoPopup(id, latlng, name, latitude, longitude, yaw, type) {
            L.popup()
                .setLatLng(latlng)
                .setContent(`
                    <div style="font-size: 14px;">
                        <strong>Waypoint 정보</strong><br>
                        <strong>Name:</strong> ${name}<br>
                        <strong>Latitude:</strong> ${latitude}<br>
                        <strong>Longitude:</strong> ${longitude}<br>
                        <strong>Yaw:</strong> ${yaw}<br>
                        <strong>Type:</strong> ${type}<br>
                        <button onclick="enterEditMode(${id})">Edit</button>
                        <button onclick="deleteWaypoint(${id})" style="color: red;">Delete</button>
                    </div>
                `)
                .openOn(map); // 지도 위에 팝업 표시
        }

        // 첫 번째 편집 모드로 전환하는 함수
        function enterEditMode(id) {
            const waypoint = currentPathWaypoints.find(wp => wp.id === id);

            if (!waypoint) {
                console.error("Waypoint를 찾을 수 없습니다.");
                return;
            }

            const { latitude, longitude, name, yaw, type } = waypoint;

            initialLatLngs[name] = [latitude, longitude]; // 초기 위치 저장
            initialYaws[name] = yaw;                      // 초기 yaw 값 저장

            const popup = L.popup()
                .setLatLng([latitude, longitude])
                .setContent(`
                    <div style="font-size: 14px;">
                        <strong>Edit Waypoint 정보</strong><br>
                        <label>Name:</label> ${name} <button onclick="enterSecondEditMode('${id}', 'name')">Edit</button><br>
                        <label>Type:</label> ${type} <button onclick="enterSecondEditMode('${id}', 'type')">Edit</button><br>
                        <strong>Latitude/Longitude:</strong> ${latitude.toFixed(6)}, ${longitude.toFixed(6)} 
                        <button onclick="enterSecondEditMode('${id}', 'location')">Edit Location</button><br>
                        <strong>Yaw:</strong> ${yaw.toFixed(2)} <button onclick="enterSecondEditMode('${id}', 'direction')">Edit Direction</button><br>
                    </div>
                `)
                .openOn(map); // 지도 위에 편집 팝업 표시
            
            popup.on('remove', closePopupAndReset);
        }

        // 두 번째 편집 모드로 전환하는 함수
        function enterSecondEditMode(id, field) {
            const waypoint = currentPathWaypoints.find(wp => wp.id === Number(id));

            if (!waypoint) {
                console.error("Waypoint를 찾을 수 없습니다.");
                return;
            }

            const { latitude, longitude, name, yaw, type } = waypoint;

            let contentHtml = `<div style="font-size: 14px;"><strong>Edit ${field} 정보</strong><br>`;

            if (field === 'name') {
                contentHtml += `
                    <label>Name:</label> <input type="text" id="editName" value="${name}"><br>
                    <button onclick="saveEditedValue('${id}', 'name')">Save</button>
                `;
            } else if (field === 'type') {
                contentHtml += `
                    <label>Type:</label> <input type="text" id="editType" value="${type}"><br>
                    <button onclick="saveEditedValue('${id}', 'type')">Save</button>
                `;
            } else if (field === 'location') {
                contentHtml += `
                    <strong>Latitude:</strong> <span id="editLatitude">${latitude.toFixed(6)}</span><br>
                    <strong>Longitude:</strong> <span id="editLongitude">${longitude.toFixed(6)}</span><br>
                    <button onclick="saveEditedValue('${id}', 'location')">Save Location</button>
                    <button onclick="closePopupAndReset()">Close</button>
                    <p style="font-size:12px;color:gray;">지도에서 아이콘을 드래그하여 새 위치를 설정하세요.</p>
                `;

                const marker = waypointLayer.getLayers().find(layer => 
                    layer instanceof L.Marker && layer.options.title === waypoint.name
                );

                if (marker) {
                    marker.dragging.enable();

                    // 드래그 시작 시 팝업을 숨깁니다
                    marker.on('dragstart', () => {
                        map.closePopup();
                    });

                    // 드래그 종료 시 위치 업데이트 및 팝업을 다시 표시
                    marker.on('dragend', (e) => {
                        const updatedLatLng = e.target.getLatLng();

                        // 드래그 종료 후 팝업을 다시 표시하는 함수
                        const updatedContentHtml = `
                            <div style="font-size: 14px;">
                                <strong>Edit Waypoint 정보</strong><br>
                                <label>Latitude:</label> <span id="editLatitude">${updatedLatLng.lat.toFixed(6)}<br>
                                <label>Longitude:</label> <span id="editLongitude">${updatedLatLng.lng.toFixed(6)}<br>
                                <button onclick="saveEditedValue('${id}', 'location')">Save Location</button>
                                <button onclick="closePopupAndReset()">Close</button>
                            </div>
                        `;

                        const popup = L.popup()
                            .setLatLng(updatedLatLng)
                            .setContent(updatedContentHtml)
                            .openOn(map);

                        popup.on('remove', closePopupAndReset); // X 버튼 또는 Close 버튼이 눌릴 때 초기화
                    });
                } else {
                    console.error("해당 ID의 마커를 찾을 수 없습니다.");
                }
            } else if (field === 'direction') {
                contentHtml += `
                    <strong>Yaw:</strong> <span id="editYaw">${yaw.toFixed(2)}</span><br>
                    <input type="range" id="yawSlider" min="0" max="${2 * Math.PI}" step="0.01" value="${yaw}">
                    <button onclick="saveEditedValue('${id}', 'direction')">Save Direction</button>
                    <button onclick="closePopupAndReset()">Close</button>
                    <p style="font-size:12px;color:gray;">슬라이더를 사용하여 방향을 조정하세요.</p>
                `;
            }

            contentHtml += `</div>`;

            // L.popup을 사용해 마커에 팝업 표시
            const popup = L.popup()
                .setLatLng([latitude, longitude])
                .setContent(contentHtml)
                .openOn(map);

            // 마커를 찾아 변수에 할당
            const marker = waypointLayer.getLayers().find(layer => 
                layer instanceof L.Marker && layer.options.title === waypoint.name
            );

            if (!marker) {
                console.error("해당 ID의 마커를 찾을 수 없습니다.");
                return;
            }

            // Popup이 열리고 난 후 슬라이더와 yaw 디스플레이 요소 가져오기
            setTimeout(() => {
                const yawDisplay = document.getElementById("editYaw");
                const yawSlider = document.getElementById("yawSlider");

                // 슬라이더 요소와 yaw 디스플레이 확인
                if (yawSlider && yawDisplay) {

                    // 슬라이더 조작 시 yaw 값 업데이트
                    yawSlider.addEventListener('input', (e) => {
                        const newYaw = parseFloat(e.target.value);
                        updateMarkerDirection(marker, newYaw); // 마커 회전 업데이트
                        yawDisplay.innerText = newYaw.toFixed(2); // yaw 값 업데이트

                    });
                } 
            }, 100); // Popup 렌더링 후 요소를 찾기 위해 약간의 지연을 추가
            popup.on('remove', closePopupAndReset);
        }

        

        // 편집 모드 취소 시 초기 값으로 되돌리는 함수
        function closePopupAndReset() {
            map.closePopup();

            waypointLayer.eachLayer(layer => {
                if (layer instanceof L.Marker && initialLatLngs[layer.options.title]) {
                    const waypointName = layer.options.title;
                    
                    // 초기 위치와 yaw 값이 존재하는 경우에만 복원
                    if (initialLatLngs[waypointName]) {
                        const [initialLat, initialLng] = initialLatLngs[waypointName];
                        layer.setLatLng([initialLat, initialLng]); // 초기 위치로 복원
                    }

                    if (initialYaws[waypointName] !== undefined) {
                        updateMarkerDirection(layer, initialYaws[waypointName]); // 초기 yaw 값으로 복원
                    }

                } 
            });
        }

        async function saveEditedValue(id, field) {
            let updateData = {};

            if (field === 'name') {
                updateData.name = document.getElementById("editName").value;
            } else if (field === 'type') {
                updateData.type = document.getElementById("editType").value;
            } else if (field === 'location') {
                const latitudeElement = document.getElementById("editLatitude");
                const longitudeElement = document.getElementById("editLongitude");

                if (!latitudeElement || !longitudeElement) {
                    console.error("Location elements not found.");
                    return;
                }

                updateData.latitude = parseFloat(latitudeElement.innerText);
                updateData.longitude = parseFloat(longitudeElement.innerText);
                
            } else if (field === 'direction') {
                updateData.yaw = parseFloat(document.getElementById("editYaw").innerText);
            }

            const { error } = await supabase.from('Waypoint').update(updateData).eq('id', id);

            if (error) {
                console.error('Waypoint 업데이트 오류:', error);
                alert('Waypoint 업데이트에 실패했습니다.');
            } else {
                alert('Waypoint 업데이트가 완료되었습니다.');
                map.closePopup();
                loadWaypointsFromDatabase(pathId);
            }
        }

        // yaw 계산 함수
        function calculateYaw(startLatLng, endLatLng) {
            const deltaX = endLatLng.lng - startLatLng.lng;
            const deltaY = endLatLng.lat - startLatLng.lat;
            return Math.atan2(deltaY, deltaX); // 라디안으로 반환
        }

        // 마커 회전 업데이트 함수
        function updateMarkerDirection(marker, yaw) {
            marker.setIcon(L.divIcon({
                className: 'custom-div-icon',
                html: `<img src="arrow.png" alt="Waypoint Icon" style="transform: rotate(${2*Math.PI-yaw}rad);"/>`,
                iconSize: [10, 10],
            }));
        }
        

        // 웨이포인트 삭제 함수
        async function deleteWaypoint(id) {
            // 사용자 확인
            const confirmDelete = confirm("정말 이 웨이포인트를 삭제하시겠습니까?");
            if (!confirmDelete) return;

            // Supabase에서 해당 웨이포인트 삭제
            const { error } = await supabase.from('Waypoint').delete().eq('id', id);

            if (error) {
                console.error('웨이포인트 삭제 오류:', error);
                alert('웨이포인트 삭제에 실패했습니다.');
            } else {
                alert('웨이포인트가 성공적으로 삭제되었습니다.');
                map.closePopup(); // 팝업 닫기
                loadWaypointsFromDatabase(pathId); // 삭제 후 Waypoints 다시 불러오기
            }
        }

        
        // Add Waypoint 모드를 활성화하여 지도에 터치 이벤트를 추가
        function enableAddWaypointMode(pathId) {

            alert("지도를 터치하여 Waypoint의 위치를 설정하세요.");
            
            let startLatLng = null; // 초기 터치 위치 저장용
            let isDragging = false;
            let tempMarker = null;

            document.addEventListener('touchstart', _onTouchStart, { passive: false });
            document.addEventListener('touchmove', _onTouchMove, { passive: false });
            document.addEventListener('touchend', _onTouchEnd, { passive: false });

            // 이벤트 바인딩
            map.on('touchstart', _onTouchStart, { passive: false });
            map.on('touchmove', _onTouchMove, { passive: false });
            map.on('touchend', _onTouchEnd, { passive: false });

            // Waypoint 생성 1단계: Point 세팅 (터치 시작)
            function _onTouchStart(e) {
                console.log("Touching!");
                // 두 손가락 이상일 경우 포인트 생성 중지
                if (e.touches.length > 1) return;

                isDragging = true;

                // 터치 위치 가져오기
                const touch = e.touches[0];
                const containerPoint = map.mouseEventToContainerPoint(touch);
                startLatLng = map.containerPointToLatLng(containerPoint);

                e.preventDefault();
                e.stopPropagation();

                map.dragging.disable(); // 맵 드래그 비활성화

                // 임시 마커 생성
                tempMarker = L.marker(startLatLng, {
                    icon: L.divIcon({
                        className: 'custom-div-icon',
                        html: '<img src="arrow.png" alt="Waypoint Icon" style="transform: rotate(0rad);"/>',
                        iconSize: [10, 10],
                    }),
                    draggable: false,
                }).addTo(map);
            }

            // Waypoint 생성 2단계: Heading 세팅 (터치한 채로 드래그)
            function _onTouchMove(e) {
                console.log("Moving!");
                if (!isDragging) return;

                e.preventDefault();
                e.stopPropagation();

                const touch = e.touches[0];
                const containerPoint = map.mouseEventToContainerPoint(touch);
                const currentLatLng = map.containerPointToLatLng(containerPoint);
                const angle = calculateHeading(startLatLng, currentLatLng);

                // yaw에 따라 아이콘 회전
                tempMarker.setLatLng(startLatLng);
                const arrowElement = tempMarker.getElement().querySelector('img');
                arrowElement.style.transform = `rotate(${1.57 - angle}rad)`;
            }

            // Waypoint 생성 3단계: 최종 Waypoint 생성 (터치 해제)
            function _onTouchEnd(e) {
                console.log("End!");
                if (!isDragging) return;

                isDragging = false;
                e.preventDefault();
                e.stopPropagation();

                map.dragging.enable(); // 맵 드래그 재활성화

                const endLatLng = map.containerPointToLatLng(map.mouseEventToContainerPoint(e.changedTouches[0]));
                const heading = calculateHeading(startLatLng, endLatLng);

                // Waypoint 세부사항 입력 팝업 열기
                openWaypointDetailsPopup(startLatLng, heading, pathId);

                // 임시 마커 제거
                map.removeLayer(tempMarker);
                tempMarker = null;

                // 이벤트 해제
                map.off('touchstart', _onTouchStart);
                map.off('touchmove', _onTouchMove);
                map.off('touchend', _onTouchEnd);

                // `document` 이벤트 해제 (중복 방지)
                document.removeEventListener('touchstart', _onTouchStart);
                document.removeEventListener('touchmove', _onTouchMove);
                document.removeEventListener('touchend', _onTouchEnd);
            }
        }


        // Waypoint 상세 정보 입력 팝업
        function openWaypointDetailsPopup(latlng, yaw, pathId) {

            const waypointPopup = document.createElement('div');
            waypointPopup.id = 'newWaypointPopup';
            waypointPopup.style = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 90%;
                max-width: 300px;
                padding: 20px;
                background-color: #ffffff;
                border-radius: 8px;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
                font-size: 14px;
                z-index: 1000;
            `;

            waypointPopup.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3 style="margin: 0; font-size: 18px;">Add Waypoint</h3>
                    <button onclick="closeWaypointPopup()" style="background: none; border: none; font-size: 20px; font-weight: bold; cursor: pointer;">&times;</button>
                </div>
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    <label>Name (순서):</label>
                    <input type="number" id="newWaypointName" placeholder="Enter Order" style="padding: 8px; border: 1px solid #ddd; border-radius: 5px; font-size: 14px;" min="1" />
                    
                    <label>Description:</label>
                    <input type="text" id="newWaypointDescription" placeholder="Enter Description" style="padding: 8px; border: 1px solid #ddd; border-radius: 5px; font-size: 14px;"/>

                    <label>Type:</label>
                    <input type="text" id="newWaypointType" placeholder="Enter Type" style="padding: 8px; border: 1px solid #ddd; border-radius: 5px; font-size: 14px;"/>
                </div>
                <div style="display: flex; justify-content: space-between; margin-top: 15px;">
                    <button onclick="addNewWaypoint(${latlng.lat}, ${latlng.lng}, ${yaw}, ${pathId})" style="width: 48%; padding: 10px; font-size: 16px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">Save</button>
                    <button onclick="closeWaypointPopup()" style="width: 48%; padding: 10px; font-size: 16px; background-color: #f8f9fa; color: black; border: 1px solid #ddd; border-radius: 5px; cursor: pointer;">Cancel</button>
                </div>
            `;

            document.body.appendChild(waypointPopup);
        }

        // Waypoint 추가 함수
        async function addNewWaypoint(latitude, longitude, yaw, pathId) {
            const name = parseInt(document.getElementById("newWaypointName").value);
            const description = document.getElementById("newWaypointDescription").value;
            const type = document.getElementById("newWaypointType").value;
            const color = getRandomColor(); // 랜덤 색상 생성

            if (isNaN(name) || !description || !type) {
                alert("모든 필드를 정확히 입력하세요.");
                return;
            }

            // 이름을 기준으로 순서 정렬 (중간 삽입 가능)
            await adjustWaypointOrder(pathId, name);

            const { error } = await supabase.from('Waypoint').insert([{ pathId, latitude, longitude, yaw, color, name, description, type }]);

            if (error) {
                console.error("Waypoint 추가 오류:", error);
                alert("Waypoint 추가에 실패했습니다.");
            } else {
                alert("새로운 Waypoint가 추가되었습니다.");
                closeWaypointPopup();
                // 추가 후 Waypoints 목록을 다시 불러오거나 업데이트하는 함수를 호출해 갱신
            }
        }

        // 순서 정렬을 위한 Waypoint 이름 조정 함수
        async function adjustWaypointOrder(pathId, newOrder) {
            const { data: waypoints, error } = await supabase.from('Waypoint')
                .select('id, name')
                .eq('pathId', pathId)
                .order('id', { ascending: true });

            if (error) {
                console.error('Waypoint 순서 조정 오류:', error);
                return;
            }

            const updates = [];
            let currentOrder = newOrder;

            // 새 Waypoint가 중간에 삽입될 경우 이후 Waypoints의 name을 증가
            waypoints.forEach(waypoint => {
                if (waypoint.name >= newOrder) {
                    updates.push(supabase.from('Waypoint').update({ name: ++currentOrder }).eq('id', waypoint.id));
                }
            });

            await Promise.all(updates); // 모든 업데이트 작업 수행
        }

        // 팝업 닫기 함수
        function closeWaypointPopup() {
            const waypointPopup = document.querySelector('#newWaypointPopup');
            if (waypointPopup) {
                document.body.removeChild(waypointPopup);
            }
        }

        // 랜덤 색상 생성 함수
        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

    </script>
</body>
</html>