<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Waypoint Map</title>

    <!-- Leaflet.js 라이브러리의 CSS 및 JS 파일 포함 -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>
    <!-- YAML 라이브러리 (js-yaml) 포함 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <!-- jQuery 라이브러리 추가 -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <!-- jquery.finger.js 라이브러리 추가 -->
    <script src="//rawgit.com/ngryman/jquery.finger/v0.1.2/dist/jquery.finger.js"></script>

    <!-- Supabase 클라이언트 라이브러리 추가 -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js"></script>

    <script>
        document.addEventListener("DOMContentLoaded", () => {
            // Supabase 설정 - URL과 익명 키를 본인의 것으로 교체하세요
            const SUPABASE_URL = 'https://wbjwefiaglmtwdtulhbo.supabase.co';
            const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndiandlZmlhZ2xtdHdkdHVsaGJvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MjE0NzAzMjksImV4cCI6MjAzNzA0NjMyOX0.vKQBE2k0qU2SsRMH8sVN0RKdByWGLQ6d_MxgB8J5EOE';
            window.supabase = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY); // window 객체에 추가하여 전역으로 사용 가능하도록 설정
        });
    </script>

    <style>
        /* Mobile App 제목 폰트 스타일 */
        #title {
            font-family: 'Arial', sans-serif; /* 원하는 글꼴 */
            font-size: 21px; /* 폰트 크기 조정 */
            font-weight: bold; /* 글씨 굵기 */
            text-align: center; /* 텍스트 중앙 맞춤 */
            margin-top: 20px; /* 필요에 따라 여백 추가 */
            color: #333333; /* 글씨 색상 */
        }
        /* 지도의 높이를 설정하여 화면에 표시 */
        #map {
            position: relative;
            width: 100%;         /* 너비를 100%로 설정해 화면을 채움 */
            height: 50vh;        /* 높이를 뷰포트 높이의 50%로 설정 */
        }
        /* 사이드바(오른쪽) 스타일 */
        .sidebar-right {
            position: absolute;
            top: 2vh;
            right: 0vh;
            width: 20vh;
            height: 39vh;
            max-height: 100vh;
            background-color: #f9f9f9;
            border-left: 1px solid #ddd;
            padding: 1vh;
            overflow-y: auto;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 999;
        }
        /* 사이드바가 열렸을 때 */
        .sidebar-right.open {
            transform: translateX(0);
        }
        /* 열고 닫는 버튼 스타일 */
        .toggle-sidebar-right-btn {
            position: absolute;
            top: 1vh;
            right: 2vh;
            background-color: #333;
            color: #fff;
            padding: 1vh;
            border-radius: 0.5vh;
            cursor: pointer;
            z-index: 1000;
            font-size: 1.2vh;
        }
        /* 사이드바(왼쪽) 스타일 */
        .sidebar-left {
            position: absolute;
            top: 21vh;
            left: 0vh;
            width: 25vh;
            height: 24vh;
            max-height: 100vh;
            background-color: #f9f9f9;
            border-left: 1px solid #ddd;
            padding: 1vh;
            overflow: hidden;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            z-index: 999;
        }
        /* 사이드바가 열렸을 때 */
        .sidebar-left.open {
            transform: translateX(0);
        }
        /* 열고 닫는 버튼 스타일 */
        .toggle-sidebar-left-btn {
            position: absolute;
            top: 45vh;
            left: 2vh;
            background-color: #333;
            color: #fff;
            padding: 1vh;
            border-radius: 0.5vh;
            cursor: pointer;
            z-index: 1000;
            font-size: 1.2vh;
        }
        #controls { margin: 10vh; }
        /* 표 세팅 */
        .table-container {
            display: flex;
            width: 100%;
            margin-top: 1vh;
        }
        .color-box {
            width: 3vh;
            height: 2vh;
            display: inline-block;
        }
        /* Waypoint 정보를 Table 형태로 표시 */
        #waypointTable {
            width: 40%;
            max-height: 15vh;
            overflow-y: auto;
            border-collapse: collapse;
        }
        #detailTable {
            width: 60%;
            max-height: 15vh;
            overflow-y: auto;
            border-collapse: collapse;
            display: none;
        }
        #waypointTable th, #waypointTable td, #detailTable th, #detailTable td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        #waypointTable th, #detailTable th {
            background-color: #f2f2f2;
        }
        /* 아이콘 세팅 */
        .custom-div-icon {
            background-color: #ff5722;    /* 원형 아이콘 배경색 */
            border: none;                   /* 테두리를 없애기 */
            border-radius: 50%;             /* 원형으로 만들기 */
            width: 3vh;                     /* 아이콘의 너비 */
            height: 3vh;                    /* 아이콘의 높이 */
            display: flex;                  /* 내용을 중앙에 배치하기 위한 설정 */
            justify-content: center;        /* 가로 중앙 정렬 */
            align-items: center;            /* 세로 중앙 정렬 */
            overflow: hidden;               /* 원형 영역을 넘어서는 부분을 숨기기 */
        }
        .custom-div-icon img {
            width: 100%;                    /* 이미지의 너비를 아이콘의 너비에 맞추기 */
            height: 100%;                   /* 이미지의 높이를 아이콘의 높이에 맞추기 */
            object-fit: cover;              /* 이미지의 비율 유지 및 영역에 맞게 조정 */
        }
        /* 버튼 세팅 */
        .save-button {
            position: absolute;             /* 버튼을 절대 위치로 설정 */
            right: 1vh;                     /* 화면의 오른쪽 끝에서 10px 떨어진 위치 */
        }
        /* 폰트 세팅 */
        label {
            font-family: 'Times New Roman'; /* 원하는 글꼴 이름을 설정 */
            font-size: 14px;                /* 글씨 크기 설정 */
            font-weight: bold;              /* 글씨 두께 설정 */
            color: #333;                  /* 글씨 색상 설정 */
        }
        /* 로봇 아이콘 세팅 */
        .robot-icon {
            font-size: 2vh;
            text-align: center;
            line-height: 3vh;              /* 아이콘의 세로 정렬 */
        }
        /* 팝업 스타일 수정 */
        .popup-container {
            position: fixed;
            right: 1vh;
            top: 8.5vh;
            display: flex;
            flex-direction: column;  /* 세로 방향으로 쌓기 */
            flex-wrap: wrap;         /* 아이템이 넘치면 새로운 열로 감 */
            gap: 1vh;                /* 각 팝업 사이 간격 */
            max-height: 50vh;        /* 화면 높이의 50%까지만 사용 */
            z-index: 1000;           /* 맵 위에 표시되도록 z-index 조정 */
            overflow-y: scroll;        /* 넘칠 경우 스크롤 생성 */
        }
        .popup {
            width: 18vh;
            max-width: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid black;
            padding: 1vh;
            border-radius: 0.5vh;
            box-shadow: 0vh 0vh 1vh rgba(0, 0, 0, 0.1);
            font-size: 1.2vh; /* 폰트 크기 줄이기 */
            margin-bottom: 2vh; /* 각 팝업창 간격 */
        }
        .popup h4 {
            margin: 0;
            font-size: 1.6vh; /* 제목 폰트 크기 */
        }
        .popup .info {
            margin-top: 0.3vh; /* 상단 간격 줄이기 */
        }

        .popup .info p {
            margin: 0.5vh 0; /* 각 항목 간의 간격 줄이기 */
            line-height: 2vh; /* 줄 간격 줄이기 */
        }
        /* 제목과 버튼이 한 줄에 들어가도록 컨테이너 스타일 */
        .header-container {
            display: flex;
            align-items: center;         /* 수직 중앙 정렬 */
            justify-content: space-between; /* 양쪽 끝 정렬 */
            width: 100%;                 /* 전체 너비 사용 */
            padding: 0.5vh;              /* 패딩 조정 */
            font-size: 2vh;              /* 텍스트 크기 조정 */
        }
        /* Deadlock Probability 텍스트 스타일 */
        .header-title {
            margin: 0;
            font-size: 1.8vh;
        }
        /* 버튼 컨테이너 */
        .zoom-buttons {
            display: flex;
            gap: 0.25vh;                  /* 버튼 간격 */
        }
        .zoom-buttons button {
            font-size: 1.2vh;
            padding: 0.25vh 0.5vh;          /* 버튼 크기 조정 */
        }
        /* 행렬을 감싸는 Wrapper 스타일 */
        #matrixContainerWrapper {
            width: 100%;
            height: calc(100vh - 8vh); /* 헤더와 줌 버튼을 제외한 높이 설정 */
            overflow: auto;            /* 행렬이 Wrapper를 벗어나면 스크롤 표시 */
        }
        /* 확률 행렬 스타일 */
        #probabilityMatrix {
            position: absolute;
            bottom: 1vh;
            left: 1vh;
            z-index: 2000;
            display: grid;
            gap: 0.5vh;
            margin-top: 2vh;
            background-color: rgba(255, 255, 255, 0.7); /* 반투명 흰색 배경 */
            padding: 1vh;                                 
            border-radius: 0.5vh;
            transform-origin: top left; /* 확대/축소 원점 설정 */
        }
        /* 행렬 셀 스타일 */
        .matrix-cell {
            width: 2.5vh;
            height: 2.5vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9vh;
            color: black;
            border: 1px solid #000;
        }
        /* 라벨 셀 스타일 */
        .label-init-cell {
            background-color: rgba(0, 0, 0, 0.7);       /* 반투명 검은색 배경 */
        }
        .label-cell {
            background-color: rgba(200, 200, 200, 0.7); /* 반투명 회색 배경 */
        }
        /* 확률에 따른 셀 색상 변화 */
        .low-probability { background-color: green; }
        .medium-probability { background-color: yellow; color: black; }
        .high-probability { background-color: red; }
        /* Waypoint 목록 팝업 스타일 */
        #waypoint-popup {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50vh;
            max-height: 70%;
            background-color: white;
            border: 1px solid #ccc;
            padding: 2vh;
            box-shadow: 0vh 0vh 10vh rgba(0, 0, 0, 0.1);
            overflow-y: auto; /* 내용이 넘칠 경우 스크롤바 표시 */
            z-index: 1000;
        }
        #waypoint-popup h2 { margin-top: 0; }
        #waypoint-popup ul {
            list-style-type: none;
            padding: 0;
        }
        #waypoint-popup ul li {
            cursor: pointer;
            padding: 0.5vh;
            border: 1px solid #ddd;
            margin-bottom: 0.5vh;
            text-align: center;
        }
        #popup ul li:hover {
            background-color: #f0f0f0;
        }
        #overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 500;
        }
        .item-space {
            margin-right: 1.5vh; /* 오른쪽에 10px 간격 추가 */
        }
        /* Waypoint 삭제 확인 팝업 스타일 */
        .popup-overlay {
            display: flex;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.5); /* 배경 어둡게 */
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }   
        .popup-content {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            width: 80%;
            max-width: 400px;
            text-align: center;
            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.3);
        }
        .popup-content h3 {
            margin-bottom: 20px;
        }
        .button-row-delete {
            display: flex;
            justify-content: space-around;
        }
        .button-row-delete button {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #confirmDeleteButton {
            background-color: #ff4d4d;
            color: white;
        }
        #cancelDeleteButton {
            background-color: #ccc;
            color: black;
        }
        /* Waypoint Point 정보 팝업 스타일 */
        #waypoint-popup2 {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40vh;
            max-height: 70%;
            background-color: white;
            border: 1px solid #ccc;
            padding: 0vh 2vh 0vh 2vh;
            box-shadow: 0vh 0vh 1vh rgba(0, 0, 0, 0.1);
            overflow-y: auto; /* 내용이 넘칠 경우 스크롤바 표시 */
            z-index: 1000;
        }
        #waypoint-popup2 h2 { margin-top: 0; padding: 0.5vh; }
        #waypoint-popup2 ul {
            list-style-type: none;
            padding: 0;
        }
        #waypoint-popup2 ul li {
            cursor: pointer;
            padding: 0.5vh;
            border: 1px solid #ddd;
            margin-bottom: 0.5vh;
            text-align: center;
        }
        .button-row {
            margin-top: 1vh;        /* 버튼과 위 요소 사이의 간격 */
            display: flex;          /* 플렉스박스를 사용하여 한 줄로 배치 */
            justify-content: space-between; /* 버튼 간의 공간을 자동으로 나눔 */
        }
        .button-row button {
            flex: 1;                /* 버튼의 너비를 동일하게 설정 */
            margin-right: 2vh;      /* 각 버튼 사이에 간격 추가 */
            padding: 1vh;           /* 입력란 내부에 패딩을 추가하여 여유 공간 확보 */
        }
        .button-row button:last-child {
            margin-right: 0.3vh;        /* 마지막 버튼은 오른쪽 간격을 없앰 */
        }

        .text-row {
            margin-top: 1vh;       /* 버튼과 위 요소 사이의 간격 */
            margin-bottom: 1vh;
            display: flex;          /* 플렉스박스를 사용하여 한 줄로 배치 */
            gap: 2vh;              /* 입력란 사이의 간격을 20px로 설정 */
        }
        .text-row input {
            flex-basis: 45%;        /* 입력란의 너비를 동일하게 설정 */
            padding: 1vh;           /* 입력란 내부에 패딩을 추가하여 여유 공간 확보 */
            font-size: 10px;        /* 입력란 텍스트 크기 설정 */
        }
        /* Waypoint Point 수정 팝업창 스타일 */
        #editFormPopup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 35vh;
            background-color: white;
            padding: 0vh 2vh 0vh 2vh;
            box-shadow: 0vh 0vh 1vh rgba(0, 0, 0, 0.3); /* 그림자 효과 */
            z-index: 1000; /* 배경보다 높은 z-index */
            border-radius: 0.8vh;
            text-align: center;
        }
        /* 팝업창 내부 입력 필드 스타일 */
        #editFormPopup input {
            width: 100%;
            margin: 0.5vh 0;
            padding: 0.8vh;
            box-sizing: border-box;
        }
        #editFormPopup button {
            margin: 1vh 0.5vh;
            padding: 0.8vh 1.2vh;
        }
        .popup-header {
            cursor: move;
            padding: 1vh;
            background-color: #f1f1f1;
            border-bottom: 1px solid #ddd;
            text-align: center;
        }
        .draggable-popup {
            position: absolute;
            top: 30%;
            left: 7.5%;
            width: 42vh;
            background-color: white;
            padding: 0vh 2vh 1vh 2vh;
            box-shadow: 0vh 0vh 1vh rgba(0, 0, 0, 0.3);
            z-index: 1000;
            border-radius: 0.8vh;
            text-align: center;
        }
        .draggable-popup-robot {
            position: absolute;
            top: 30%;
            left: 7.5%;
            width: 42vh;
            background-color: white;
            padding: 0vh 2vh 1vh 2vh;
            box-shadow: 0vh 0vh 1vh rgba(0, 0, 0, 0.3);
            z-index: 1000;
            border-radius: 0.8vh;
            text-align: center;
        }
        /* 지도 팝업 스타일 */
        .map-popup {
            position: absolute;
            top: 30%;
            left: 7.5%;
            transform: translate(-50%, -50%);
            width: 50vh;
            height: 30vh;
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 0vh 0vh 1vh rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none; /* 초기 상태에서는 팝업을 숨김 */
        }
        /* Point 추가용 지도 팝업 스타일 */
        .map-popup-point {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50vh;
            height: 60vh;
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 0vh 0vh 1vh rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none; /* 초기 상태에서는 팝업을 숨김 */
        }
        /* Point 추가용 지도의 Waypoint Icon 스타일 */
        .custom-div-icon .circle-icon {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 3vh;
            height: 3vh;
            border-radius: 50%;  /* 동그라미 */
            background-color: #007BFF;  /* 배경색 (파란색) */
            color: white;
            font-weight: bold;
            font-size: 12px;
            text-align: center;
        }
        /* Waypoint 목록 팝업 스타일 */
        #waypoint-save-popup {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50vh;
            max-height: 70%;
            background-color: white;
            border: 1px solid #ccc;
            padding: 2vh;
            box-shadow: 0vh 0vh 1vh rgba(0, 0, 0, 0.1);
            overflow-y: auto; /* 내용이 넘칠 경우 스크롤바 표시 */
            z-index: 1000;
        }
        #waypoint-save-popup h2 { margin-top: 0; }
        #waypoint-save-popup ul {
            list-style-type: none;
            padding: 0;
        }
        #waypoint-save-popup ul li {
            cursor: pointer;
            padding: 0.5vh;
            border: 1px solid #ddd;
            margin-bottom: 0.5vh;
            text-align: center;
        }
        /* Waypoint 저장 팝업 스타일 */
        #save-waypoint-popup {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50vh;
            max-height: 70%;
            background-color: white;
            border: 1px solid #ccc;
            padding: 2vh 1vh 2vh 1vh;
            box-shadow: 0vh 0vh 1vh rgba(0, 0, 0, 0.1);
            overflow-y: auto; /* 내용이 넘칠 경우 스크롤바 표시 */
            z-index: 1000;
        }
        #save-waypoint-popup h2 { margin-top: 0; }
        #save-waypoint-popup ul {
            list-style-type: none;
            padding: 0;
        }
        #save-waypoint-popup ul li {
            cursor: pointer;
            padding: 0.5vh;
            border: 1px solid #ddd;
            margin-bottom: 0.5vh;
            text-align: center;
        }
        .circle-number {
        width: 3vh;
        height: 3vh;
        border-radius: 50%;
        background-color: lightgray;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 1vh;
        font-weight: bold;
        }
        .waypoint-label {
        flex: 1;
        font-size: 12px;
        }
        .select-button {
        width: 8vh;
        height: 3vh;
        border: 2px solid black;
        background-color: white;
        color: black;
        border-radius: 0.5vh;
        cursor: pointer;
        }
        .select-button.selected {
        background-color: gray;
        color: white;
        }
        /* 컨트롤러 팝업 스타일 */
        .controller-popup {
            position: fixed;
            bottom: 6vh;
            right: 5.75vh;
            width: 39vh;
            height: 22vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0vh 0vh 1vh rgba(0, 0, 0, 0.3);
            border-radius: 1vh;
            z-index: 1000;
            flex-direction: column; /* 세로 방향으로 정렬 */
            padding: 1vh; /* 팝업 안쪽 여백 추가 */
        }
        .controller-container {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-top: 2vh; /* 아래쪽 여백 제거 */
            padding: 0 2vh; /* 양쪽에 동일한 패딩 추가 */
        }
        /* 컨트롤러 버튼 스타일 */
        .controller-btn {
            width: 5vh;
            height: 5vh;
            font-size: 1.5em;
            background: #d9d9d9;
            border: none;
            border-radius: 0.8vh;
            margin: 0.2vh;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;               /* 버튼 내용 가운데 정렬 */
            justify-content: center;
            align-items: center;
            box-shadow: 0vh 0vh 1.5vh rgba(0, 0, 0, 0.2);
            padding: 2vh;
            flex-direction: column;
        }
        .controller-btn:active {
            background: #a6a6a6;
        }
        .controller-grid {
            display: grid;
            grid-template-areas:
                ". up ."
                "left stop right"
                ". down .";
            gap: 0.5vh;
            padding-left: 1.5vh; /* 왼쪽 여백 추가 */
        }
        .controller-btn.up { grid-area: up; }
        .controller-btn.down { grid-area: down; }
        .controller-btn.left { grid-area: left; }
        .controller-btn.right { grid-area: right; }
        .controller-btn.stop { grid-area: stop; }
        .speed-control {
            display: flex;
            justify-content: space-between;
            width: 100%;
            gap: 0.5vh;
            margin-left: 1vh; /* 왼쪽 여백 추가 */
        }
        
        .speed-control-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0; /* 상하 여백 제거 */
        }
        
        .speed-display {
            font-size: 1.8vh;
            font-weight: bold;
            margin: 0.5vh 0;
        }
        
        .adjust-buttons {
            display: flex;
            flex-direction: column;
            gap: 1vh;
        }
        /* Close 버튼 스타일 */
        .close-button {
            position: relative;
            top: -2vh;
            right: -9.9vh; /* 오른쪽으로 약간 이동 */
            font-size: 2vh; /* 버튼 크기 조정 */
            margin-bottom: 0; /* 아래쪽 여백 제거 */
            border-radius: 0.8vh; /* 둥근 모서리 설정 */
        }
    </style>
</head>
<body>
    <h3 id="title">Zeta Satellite Robotics Waypoint Editor</h3>
    <!-- 지도가 표시될 영역 -->
    <div id="map">
        <!-- 사이드바(오른쪽) 열기/닫기 버튼 -->
        <div class="toggle-sidebar-right-btn" onclick="toggleSidebarRight()">Info</div>

        <!-- 사이드바(오른쪽) (로봇 정보 팝업 저장) -->
        <div id="sidebar-right" class="sidebar-right">
            <h3 style="font-size: 2vh;">Robot Information</h3>
            <!-- 로봇 정보 팝업이 추가될 영역 -->
            <div id="robotInfoContainer"></div>
        </div>

        <!-- 사이드바(왼쪽) 열기/닫기 버튼 -->
        <div class="toggle-sidebar-left-btn" onclick="toggleSidebarLeft()">Deadlock</div>

        <!-- 사이드바(왼쪽) (로봇 교착 확률 행렬) -->
        <div id="sidebar-left" class="sidebar-left">
            <div class="header-container">
                <h3 class="header-title">Deadlock Probability</h3>
                <div class="zoom-buttons">
                    <button onclick="zoomIn()">+</button>
                    <button onclick="zoomOut()">-</button>
                </div>
            </div>
            <!-- 행렬을 감싸는 Wrapper 추가 -->
            <div id="matrixContainerWrapper">
                <div id="probabilityMatrix">
                    <!-- 교착 확률 행렬이 동적으로 추가 -->
                </div>
            </div>
        </div>
    </div>
    <!-- 사용자가 로봇을 추가 및 제어할 수 있는 버튼 -->
    <div id="robot-control">
        <label>[Robot Control] </label>
        <button onclick="addRobotPopup()" id="addRobotButton">Add Robot</button>
        <select id="robotDropdown">
            <option value="">Select a Robot</option>
        </select>
        <button onclick="toggleControlMode()">Control Mode</button>
        <!-- <input type="file" id="fileInput" accept=".yaml" />
        <button id="loadWaypointButton">Load Waypoint</button> -->
        <button id="waypointListButton">Waypoint List</button>
        <button onclick="speedUpdatePopup()">Update Speed</button>
        <button onclick="robotController()">Robot Controller</button>
    </div>
    <!-- 저장할 YAML 파일명 입력 팝업 -->
    <div id="overlay" style="display: none;"></div>
    <div id="addRobotPopup" class="draggable-popup-robot" style="display:none;">
        <div id="popupHeader" class="popup-header"></div>
        <h3>Enter Robot ID & IP</h3>
        <div class="text-row">
            <input type="text" id="robotID" placeholder="Input Robot ID" />
            <input type="text" id="robotIP" placeholder="Input Robot IP" />
        </div>
        <div class="button-row">
            <button onclick="addRobotFromInput()">Add</button>
            <button onclick="closeAddRobotPopup()">Close</button>
        </div>
    </div>
    <!-- Waypoint 목록 -->
    <div id="overlay" style="display: none;"></div>
    <div id="waypoint-popup">
        <h2>Waypoint List</h2>
        <button id="reverseButton" onclick="toggleReverseMode()">Reverse</button>
        <ul id="file-list"></ul>
        <button id="closeButton">Close</button>
    </div>
    <!-- Waypoint 삭제 확인 팝업 -->
    <div id="deleteConfirmationPopup" class="popup-overlay" style="display: none;">
        <div class="popup-content">
            <h3>Are you sure you want to delete that file?</h3>
            <div class="button-row-delete">
                <button id="confirmDeleteButton" onclick="deleteFile()">Delete</button>
                <button id="cancelDeleteButton" onclick="cancelDelete()">Cancel</button>
            </div>
        </div>
    </div>
    <!-- Waypoint 확인용 지도 팝업 -->
    <div id="mapPopup" class="map-popup"></div>
    <!-- Waypoint Point 정보 팝업 -->
    <div id="waypoint-popup2" class="draggable-popup" style="display:none;">
        <div id="popupHeader" class="popup-header"></div>
        <h2>Waypoint Info</h2>
        <ul id="waypointList"></ul>
        <button onclick="openPointPopup()">Add Point</button>
        <div class="button-row">
            <button onclick="overwriteWaypoint()">Overwrite</button>
            <button onclick="openFileNamePopup()">Save As New</button>
            <button onclick="closeWaypointPopup()">Close</button>
        </div>
    </div>
    <!-- Waypoint Point 추가용 지도 팝업 -->
    <div id="mapPopupPointPage" class="map-popup-point">
        <div id="popupHeader" class="popup-header"></div>
        <!-- 지도 영역 -->
        <div id="mapPopupPoint" style="width: 100%; height: 400px;"></div>
        <div id="point-edit">
            <label>[Setting] </label>
            <input type="text" id="point_index" placeholder="Input Point Index" />
            <button onclick="addPoint()">Add</button>
            <button onclick="cancelPoint()">Cancel</button>
            <button onclick="togglePointLine()">Line</button>
        </div>
        <div class="button-row">
            <button onclick="saveMapPopupPoint()">Save</button>
            <button onclick="closeMapPopupPoint()">Close</button>
        </div>
    </div>
    <!-- 새로운 YAML 파일명 입력 팝업 -->
    <div id="fileNamePopup" class="draggable-popup" style="display:none;">
        <div id="popupHeader" class="popup-header"></div>
        <h3>Enter New File Name</h3>
        <input type="text" id="newFileName" placeholder="Enter file name">
        <button onclick="saveAsNew()">Save</button>
        <button onclick="closeFileNamePopup()">Close</button>
    </div>
    <!-- 사용자가 Point 정보를 수정할 수 있는 팝업 -->
    <div id="editFormPopup" class="draggable-popup" style="display: none;">
        <div id="popupHeader" class="popup-header"></div>
        <h3>Point Edit</h3>
        <label for="latInput">Latitude:</label>
        <input type="text" id="latInput">
        <label for="lngInput">Longitude:</label>
        <input type="text" id="lngInput">
        <label for="headingInput">Heading:</label>
        <input type="text" id="headingInput">
        <button onclick="saveEditedWaypoint()">Save</button>
        <button onclick="closeEditPopup()">Close</button>
    </div>
    <!-- 컨트롤러 팝업 -->
    <div id="controllerPopup" class="controller-popup" style="display: none;">
        <div class="controller-container">
            <!-- 방향 조작 버튼 (왼쪽) -->
            <div class="controller-grid">
                <button class="controller-btn up" onclick="sendControl('forward')">↑</button>
                <button class="controller-btn left" onclick="sendControl('left')">←</button>
                <button class="controller-btn stop" onclick="sendControl('stop')">■</button>
                <button class="controller-btn right" onclick="sendControl('right')">→</button>
                <button class="controller-btn down" onclick="sendControl('backward')">↓</button>
            </div>
    
            <!-- 속도 조절 (오른쪽) -->
            <div class="speed-control">
                <!-- 선속도 조절 -->
                <div class="speed-control-section">
                    <label>Linear</label>
                    <div class="speed-display" id="linearSpeedDisplay">0.5</div>
                    <div class="adjust-buttons">
                        <button onclick="adjustSpeed('linear', 0.05)">▲</button>
                        <button onclick="adjustSpeed('linear', -0.05)">▼</button>
                    </div>
                </div>
    
                <!-- 각속도 조절 -->
                <div class="speed-control-section">
                    <label>Angular</label>
                    <div class="speed-display" id="angularSpeedDisplay">0.5</div>
                    <div class="adjust-buttons">
                        <button onclick="adjustSpeed('angular', 0.05)">▲</button>
                        <button onclick="adjustSpeed('angular', -0.05)">▼</button>
                    </div>
                </div>
            </div>
        </div>
        <!-- Close 버튼 -->
        <div class="close-button">
            <button onclick="closeControllerPopup()">Close</button>
        </div>
    </div>
    <!-- 로봇 속도 업데이트 팝업 -->
    <div id="overlay" style="display: none;"></div>
    <div id="speedUpdatePopup" class="draggable-popup" style="top: 65%; display:none;">
        <div id="popupHeader" class="popup-header"></div>
        <h3>Enter New Robot Speed</h3>
        <input type="text" id="robotSpeed" placeholder="Enter robot speed">
        <button onclick="updateRobotSpeed()">Update</button>
        <button onclick="closeSpeedUpdatePopup()">Close</button>
    </div>
    <!-- 사용자가 Waypoint를 생성 및 저장할 수 있는 버튼 -->
    <div id="waypoint-edit">
        <label>[Waypoint Edit] </label>
        <button onclick="resetMap()">Reset</button>
        <!-- <button onclick="startNewGroup()">Start New Group</button> -->
        <!-- <input type="color" id="colorPicker" value="#0000ff">  -->
        <!-- <button onclick="toggleSelectMode()">Select Mode</button> -->
        <button id="saveWaypointButton">Save Waypoint</button>
    </div>
    <!-- 저장 Waypoint 목록 -->
    <div id="overlay" style="display: none;"></div>
    <div id="save-waypoint-popup">
        <h2>Waypoint Save List</h2>
        <select id="task">
            <option value="">Select a Task</option>
            <option value="delivery">Delivery</option>
            <option value="return">Return</option>
        </select>
        <select id="departure">
            <option value="">Select a Departure</option>
            <option value="garage">Garage</option>
            <option value="newton">Newton</option>
            <option value="hyundong">Hyundong</option>
            <option value="nehemia">Nehemia</option>
        </select>
        <select id="destination">
            <option value="">Select a Destination</option>
            <option value="garage">Garage</option>
            <option value="newton">Newton</option>
            <option value="hyundong">Hyundong</option>
            <option value="nehemia">Nehemia</option>
        </select>
        <ul id="file-save-list"></ul>
        <button id="saveButton">Save</button>
        <button id="saveCloseButton">Close</button>
    </div>

    <!-- 새로운 DB Data 섹션 -->
    <div id="db-data-section">
        <label>[DB Data]</label>
        <button onclick="openDBRobotPopup()"> DB Waypoint List </button>
        <button id="startNavigationBtn" onclick="startNavigation(selectedPathId)">Start Navigation</button>
        <button id="reverseNavigationBtn" onclick="startReverseNavigation(selectedPathId)">Reverse Waypoint</button>
    </div>

    <!-- DB Robot 데이터 표시 팝업 -->
    <div id="dbRobotPopup" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 90%; max-width: 400px; padding: 20px; background-color: #ffffff; border-radius: 8px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); z-index: 1000;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h3 style="margin: 0; font-size: 18px;">DB Robot 목록</h3>
            <div style="display: flex; gap: 8px;">
                <button onclick="openAddRobotPopup()" style="background: none; border: none; font-size: 14px; padding: 5px 10px; background-color: #007bff; color: white; border-radius: 5px; cursor: pointer;">+Add</button>
                <button onclick="closeDBRobotPopup()" style="background: none; border: none; font-size: 20px; font-weight: bold; cursor: pointer;">&times;</button>
            </div>
        </div>

        <div id="robotListDisplay" style="display: flex; flex-direction: column; gap: 10px; max-height: 300px; overflow-y: auto; padding-right: 5px;"></div>

        <button onclick="closeDBRobotPopup()" style="margin-top: 20px; width: 100%; padding: 10px; font-size: 16px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">닫기</button>
    </div>

    <!-- Path 목록을 표시하는 팝업 -->
    <div id="pathListPopup" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 90%; max-width: 400px; padding: 20px; background-color: #ffffff; border-radius: 8px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); z-index: 1000;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h3 style="margin: 0; font-size: 18px;">Path 목록</h3>
            <div style="display: flex; gap: 8px;">
                <button onclick="openAddPathPopup()" style="background: none; border: none; font-size: 14px; padding: 5px 10px; background-color: #007bff; color: white; border-radius: 5px; cursor: pointer;">+Add</button>
                <button onclick="closePathListPopup()" style="background: none; border: none; font-size: 20px; font-weight: bold; cursor: pointer;">&times;</button>
            </div>
        </div>

        <!-- Path 목록을 표시할 영역 -->
        <div id="pathListDisplay" style="display: flex; flex-direction: column; gap: 10px; max-height: 300px; overflow-y: auto; padding-right: 5px;"></div>

        <button onclick="closePathListPopup()" style="margin-top: 20px; width: 100%; padding: 10px; font-size: 16px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">닫기</button>
    </div>

    <!-- 저장할 YAML 파일명 입력 팝업 -->
    <div id="yamlFileNamePopup" class="draggable-popup" style="display:none;">
        <div id="popupHeader" class="popup-header"></div>
        <h3>Enter New Yaml File Name</h3>
        <input type="text" id="newYamlFileName" placeholder="Enter file name">
        <button onclick="saveWaypoint()">Save</button>
        <button onclick="closeYamlFileNamePopup()">Close</button>
    </div>
    <div class="table-container">
        <table id="waypointTable">
            <tbody id="waypointBody"></tbody>
        </table>
        <table id="detailTable">
            <tbody id="detailBody"></tbody>
        </table>
    </div>



    <script>
        // 지도를 초기화하고, #map 요소에 연결
        // 초기 지도의 중심과 줌 레벨을 설정 // 위치: 한동대학교
        // map.setView([36.10332441762193, 129.38886749661228], 17);
        // 시뮬레이션 용 설정 // 위치: Sonoma Raceway
        var map = L.map('map').setView([34.9682601, 127.4821126], 17);

        // OpenStreetMap 타일을 추가하여 지도에 표시
        L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '© OpenStreetMap'
        }).addTo(map);

        // Layer 그룹 설정
        var robotLayer = L.layerGroup().addTo(map); // WebSocket을 통해 실시간 위치를 표시할 Layer
        var waypointLayer = L.layerGroup().addTo(map); // DB에서 불러온 Waypoint를 표시할 Layer

        // 팝업용 지도 초기화 (Leaflet 사용)
        var mapPopup = L.map('mapPopup').setView([34.9682601, 127.4821126], 18); // 기본 좌표 설정
        L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '© OpenStreetMap'
        }).addTo(mapPopup);

        // 팝업용 지도(포인트 추가) 초기화 (Leaflet 사용)
        var mapPopupPoint = L.map('mapPopupPoint').setView([34.9682601, 127.4821126], 18); // 기본 좌표 설정
        L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '© OpenStreetMap'
        }).addTo(mapPopupPoint);
        
        let waypoints = [];                 // Waypoints를 저장할 배열
        let totalWaypoints = [];            // 전체 Waypoints를 저장할 배열
        let groupCounter = 0;               // Waypoints 그룹 카운터
        let pointCounter = 1;               // Waypoints의 point 카운터
        let waypoint_lines = {};            // Waypoints의 line을 저장할 객체
        let selectMode = false;             // Select Mode 상태 저장
        let controlMode = false;            // Control Mode 상태 저장
        let controlPoints = [];             // Control Points를 저장할 배열
        let tempLabel = '';                 
        let robots = {};                    // 로봇 정보를 저장하는 객체
        let selectedRobotID = null;         // 선택된 로봇을 저장하는 변수
        let selectedWaypointSocket = {};    // 선택된 로봇의 waypoint websocket을 저장
        let selectedControlSocket = {};     // 선택된 로봇의 control websocket을 저장
        let selectedSpeedSocket = {};       // 선택된 로봇의 speed websocket을 저장
        let selectedRemoteSocket = {};      // 선택된 로봇의 remote websocket을 저장
        let robotCounter = 1;               // 선택된 로봇 카운터
        let robotCurrentWaypoints = {};     // 로봇의 현재 위치를 저장하는 객체
        let deadlockDetected = {};          // 로봇의 교착 상태 여부 및 포인트를 저장하는 객체
        let deadlockPriority = {};          // 로봇의 교착 상태 우선순위 로봇 객체를 저장하는 객체
        let deadlockSolveFlag = {};         // 로봇의 교착 상태 해결 플래그를 저장하는 객체
        let selectedRobotWaypoints = {};    // 선택된 로봇의 주행 경로를 저장하는 함수
        let currentYamlData = null;         // 현재 YAML 데이터를 저장하는 변수
        let reverseMode = false;            // Reverse 모드 상태 변수
        let mapPopupWaypoints = [];         // 팝업용 지도의 Waypoints를 저장할 배열
        let popupWaypoint_lines = [];       // 팝업용 지도의 Waypoints의 line을 저장할 배열
        let mapPopupPointWaypoints = [];    // 팝업용 지도(Point 추가)의 Waypoints를 저장할 배열
        let popupPointWaypoint_lines = [];  // 팝업용 지도(Point 추가)의 Waypoints의 line을 저장할 배열
        let pointLineMode = true;           // 팝업용 지도(Point 추가)의 Waypoint Line 시각화 모드 상태 변수
        let popupPointCounter = 1;          // 팝업용 지도(Point 추가)의 Waypoint의 point 카운터
        let addPointMode = false;           // 팝업용 지도(Point 추가)의 Point 추가 모드 상태 저장
        let addPopupWaypoints = [];         // 팝업용 지도(Point 추가)에 추가되는 Point를 저장할 배열
        let saveSelectedWaypoints = [];     // Waypoints 중에서 저장하기 위해 선택된 Waypoint를 저장할 배열
        let viewFileMode = false;           // Waypoint 파일 시각화 상태 저장
        let deleteYamlFileName = null;      // 삭제하는 YAML 파일명을 저장하는 변수
        let scale = 1;                      // 로봇 교착 확률 행렬 스케일을 저장하는 변수
        let linearSpeed = 0.5;              // 로봇 원격 제어의 초기 선속도
        let angularSpeed = 0.5;             // 로봇 원격 제어의 초기 각속도

        // Mobile 손가락 제어 변수 세팅
        $.Finger = {
            pressDuration: 300,
            doubleTapInterval: 300,
            flickDuration: 150,
            motionThreshold: 5
        };

        // 터치 이벤트 전파 방지
        const sidebarRight = document.getElementById('sidebar-right');
        const sidebarLeft = document.getElementById('sidebar-left');

        sidebarRight.addEventListener('touchstart', (e) => e.stopPropagation(), { passive: true });
        sidebarRight.addEventListener('touchmove', (e) => e.stopPropagation(), { passive: true });
        sidebarRight.addEventListener('touchend', (e) => e.stopPropagation(), { passive: true });
        sidebarLeft.addEventListener('touchstart', (e) => e.stopPropagation(), { passive: true });
        sidebarLeft.addEventListener('touchmove', (e) => e.stopPropagation(), { passive: true });
        sidebarLeft.addEventListener('touchend', (e) => e.stopPropagation(), { passive: true });

        // 교착 확률 시각화 행렬
        const matrixContainer = document.getElementById('probabilityMatrix');
        const zoomStep = 0.1; // 줌 인/아웃 스텝 설정

        // 스크롤 시 지도에서 이벤트 전파 방지
        matrixContainer.addEventListener('touchstart', function(event) {
            event.stopPropagation(); // 이벤트 전파 방지
        }, { passive: false });

        matrixContainer.addEventListener('touchmove', function(event) {
            event.stopPropagation(); // 이벤트 전파 방지
        }, { passive: false });

        // 로봇이 도착을 인식하는 거리 (현재: 시뮬레이션)
        const robotArrivedDistance = 0.33615246791265885; 

        // 로봇의 최대 속도 (일반적으로 해당 속도로 주행)
        const maxRobotSpeed = 0.50;

        // 거리에 따라 부여된 장소 점수
        const locationScore = {
            hyundong: 1,
            nehemia: 2,
            newton: 3
        }

        // 유형에 따라 부여된 작업 점수
        const taskPriority = {
            return: 1,
            delivery: 2
        }

        // Waypoint 목록용 변수 선언
        const waypointListButton = document.getElementById('waypointListButton');
        const waypointPopup = document.getElementById('waypoint-popup');
        const overlay = document.getElementById('overlay');
        const fileListElement = document.getElementById('file-list');
        const closeButton = document.getElementById('closeButton');

        // Waypoint List 버튼 클릭 시 Waypoint 목록 열기
        waypointListButton.addEventListener('touchstart', () => {
            fetchYAMLFiles();
            waypointPopup.style.display = 'block';
            overlay.style.display = 'block';
        });

        // Close 버튼 클릭 시 Waypoint 목록 닫기
        closeButton.addEventListener('touchstart', () => {
            waypointPopup.style.display = 'none';
            overlay.style.display = 'none';
        });

        // Waypoint 저장 목록용 변수 선언
        const saveWaypointButton = document.getElementById('saveWaypointButton');
        const saveWaypointPopup = document.getElementById('save-waypoint-popup');
        const saveFileListElement = document.getElementById('file-save-list');
        const saveButton = document.getElementById('saveButton');
        const saveCloseButton = document.getElementById('saveCloseButton');

        // Save Waypoint 버튼 클릭 시 Waypoint 저장 목록 열기
        saveWaypointButton.addEventListener('touchstart', () => {
            saveWaypointFilesPopup();
            saveWaypointPopup.style.display = 'block';
            overlay.style.display = 'block';
        });
        
        // Save 버튼 클릭 시 Waypoint 저장
        saveButton.addEventListener('touchstart', () => {
            // 선택된 값 가져오기
            const task = document.getElementById('task').value;
            const departure = document.getElementById('departure').value;
            const destination = document.getElementById('destination').value;

            if (!task || !departure || !destination) {
                alert("All fields must be selected!");
                return;
            }

            saveWaypointName();
        });

        // Close 버튼 클릭 시 Waypoint 저장 목록 닫기
        saveCloseButton.addEventListener('touchstart', () => {
            saveWaypointPopup.style.display = 'none';
            overlay.style.display = 'none';

            document.querySelectorAll('.select-button').forEach(btn => {
                btn.classList.remove('selected');
            });

            saveSelectedWaypoints = [];
        });

        document.getElementById('robotDropdown').addEventListener('change', updateSelectedRobot);
        
        updateSelectedRobot();

        const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'; // 알파벳 배열
        
        let isDragging = false;
        let startLatLng = null;
        let tempMarker = null;
        let touchTimeout;               // 두 손가락 터치 확인을 위한 타임아웃
        let isTwoFingerTouch = false;   // 두 손가락 터치 여부 확인
        let pointMode = false;          // 포인트 생성 기능을 위한 변수

        // 커스텀 토글 버튼
        const toggleButton = L.control({ position: 'bottomright' });
        toggleButton.onAdd = function () {
            const div = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-custom');
            div.innerHTML = 'Point Mode OFF';
            div.style.backgroundColor = 'white';
            div.style.borderRadius = '0.5vh';
            div.style.padding = '0.5vh';
            div.style.cursor = 'pointer';

            // 모바일에서 터치 및 클릭 이벤트 추가
            L.DomEvent.disableClickPropagation(div);
            L.DomEvent.on(div, 'touchstart', function(e) {
                L.DomEvent.stopPropagation(e);
                pointMode = !pointMode;
                div.innerHTML = pointMode ? 'Point Mode ON' : 'Point Mode OFF';
                div.style.backgroundColor = pointMode ? '#4CAF50' : 'white';

                // if (pointMode) {
                //     enablePointMode();
                // } else {
                //     disablePointMode();
                // }
            });

            return div;
        };
        toggleButton.addTo(map);

        // ==================================================================
        //
        //                  Waypoint 생성 및 편집 관련 함수
        //
        // ==================================================================

        // // Point Mode 활성화 함수
        function enablePointMode() {
            $('#map').on('touchstart', onTouchStart);
            $('#map').on('touchmove', onTouchMove);
            $('#map').on('touchend', onTouchEnd);
        }

        // Point Mode 비활성화 함수
        function disablePointMode() {
            $('#map').off('touchstart', onTouchStart);
            $('#map').off('touchmove', onTouchMove);
            $('#map').off('touchend', onTouchEnd);
        }

        // Waypoint 생성 1단계: Point 세팅 (화면 터치)
        function onTouchStart(e) {
            // 기존 타임아웃 및 상태 초기화
            clearTimeout(touchTimeout);
            isTwoFingerTouch = false;
            isDragging = false;

            // 두 손가락 이상일 경우 포인트 생성 중지
            if (e.touches.length > 1) { 
                isTwoFingerTouch = true;
                return;
            }

            touchTimeout = setTimeout(() => {
                if(!isTwoFingerTouch && e.touches.length === 1) {
                    isDragging = true;
           
                    // 원래 이벤트 객체에서 터치 위치 가져오기
                    const touch = e.touches[0];
                    const containerPoint = map.mouseEventToContainerPoint(touch); 
                    startLatLng = map.containerPointToLatLng(containerPoint);
                    
                    e.preventDefault();
                    e.stopPropagation();

                    map.dragging.disable();

                    tempMarker = L.marker(startLatLng, {
                        icon: L.divIcon({
                            className: 'custom-div-icon',
                            html: '<img src="robot_1.png" alt="Custom Icon"/>',
                            iconSize: [15, 15],
                        }),
                        draggable: false,
                    }).addTo(map);
                }
            }, 50);
        }

        // Waypoint 생성 2단계: Heading 세팅 (터치한 채로 드래그)
        function onTouchMove(e) {
            if (!isDragging) return;

            e.preventDefault();
            e.stopPropagation();

            const touch = e.touches[0];
            const containerPoint = map.mouseEventToContainerPoint(touch); 
            const currentLatLng = map.containerPointToLatLng(containerPoint);
            const angle = calculateHeading(startLatLng, currentLatLng);

            tempMarker.setLatLng(startLatLng);

            const arrowElement = tempMarker.getElement().querySelector('img');
            arrowElement.style.transform = `rotate(${1.57-angle}rad)`;
        }

        // Waypoint 생성 3단계: 최종 Waypoint 생성 (터치 해제)
        function onTouchEnd(e) {
            clearTimeout(touchTimeout); 
            if (!isDragging || isTwoFingerTouch) return; 
            
            isDragging = false;
            e.preventDefault();
            e.stopPropagation();

            const endLatLng = map.containerPointToLatLng(map.mouseEventToContainerPoint(e.changedTouches[0]));
            const color = document.getElementById('colorPicker').value;
            const label = `${ALPHABET[groupCounter]}-${pointCounter}`;
            const heading = calculateHeading(startLatLng, endLatLng);

            let waypointToUse = findNearestWaypoint(startLatLng);
            
            if (controlMode === false) {
                if (waypointToUse) {
                    startLatLng = waypointToUse.latlng;
                }
                const waypoint = L.marker(startLatLng, {
                    title: label,
                    icon: L.divIcon({ 
                        className: 'custom-div-icon',
                        html: '<img src="robot_1.png" alt="Custom Icon"/>',
                        iconSize: [15, 15],
                    }),
                    draggable: false,
                }).addTo(map);
    
                const arrowElement = waypoint.getElement().querySelector('img');
                arrowElement.style.transform = `rotate(${1.57-heading}rad)`;
    
                waypoint.label = label;
                waypoint.color = color;
                waypoint.latlng = startLatLng;
                waypoint.heading = heading;
                waypoint.type = 'waypoint_follower';
                waypoint.robot = '';

                waypoints.push({ 
                    marker: waypoint, 
                    color: color, 
                    latlng: startLatLng, 
                    label: label,
                    heading: heading,
                    type: 'waypoint_follower',   // 기본 타입을 waypoint_follower로 
                    robot: ''
                });
        
                // Waypoints 간의 선 연결
                if (waypoints.length > 1) {
                    const previousWaypoint = waypoints[waypoints.length - 2].marker.getLatLng();
                    const polyline = L.polyline([previousWaypoint, startLatLng], { color: color }).addTo(map);

                    // 선을 그룹별로 저장
                    if (!waypoint_lines[label.charAt(0)]){
                        waypoint_lines[label.charAt(0)] = [];
                    }
                    waypoint_lines[label.charAt(0)].push(polyline);
                }
        
                // 표에 Waypoints 정보 추가
                if (pointCounter === 1) addWaypointToTable(label, color, waypoint.robot);
        
                pointCounter++; // point 카운터 증가
            }
            else if (controlMode === true) {         
                const controlPoint = L.marker(startLatLng, {
                    icon: L.divIcon({ 
                        className: 'custom-div-icon',
                        html: '<img src="robot_2.png" alt="Custom Icon"/>',
                        iconSize: [15, 15],
                    }),
                    draggable: true,
                }).addTo(map);
    
                const arrowElement = controlPoint.getElement().querySelector('img');
                arrowElement.style.transform = `rotate(${1.57-heading}rad)`;
                
                controlPoint.color = color;
                controlPoint.latlng = startLatLng;
                controlPoint.heading = heading;
                controlPoint.type = 'waypoint_follower';
                controlPoint.robot = '';

                controlPoints.push({ 
                    marker: controlPoint, 
                    color: color, 
                    latlng: startLatLng, 
                    label: label,
                    heading: heading,
                    type: 'waypoint_follower',   // 기본 타입을 waypoint_follower로 
                    robot: ''
                });

                const waypointData = {
                    latitude: startLatLng.lat,
                    longitude: startLatLng.lng,
                    heading: heading
                };

                selectedControlSocket[selectedRobotID].send(JSON.stringify(waypointData));
                console.log("Sent waypoint data:", waypointData);
            }

            map.dragging.enable();
            map.removeLayer(tempMarker);
        }

        // // 새로운 Waypoint 편집을 시작하는 함수
        // function startNewGroup() {
        //     if (waypoints.length > 0) {
        //         totalWaypoints.push(waypoints); // 이전 Waypoints를 저장
        //     }
        //     waypoints = [];     // Waypoints 초기화
        //     pointCounter = 1;   // point 카운터 초기화 
        //     groupCounter++;     // 그룹 카운터 증가
        // }

        // Reset 함수
        function resetMap() {
            // 이전 Waypoints를 저장
            totalWaypoints.push(waypoints); // 이를 통해 모든 Icon 제거 가능

            // 지도에서 모든 Waypoints 제거
            totalWaypoints.forEach(group => {
                group.forEach(point => {
                    map.removeLayer(point.marker);
                });
            });

            // 지도에서 모든 Control Points 제거
            controlPoints.forEach(point => {
                map.removeLayer(point.marker);
            })

            // 지도에서 모든 Waypoints line 제거
            Object.keys(waypoint_lines).forEach(groupLabel => {
                waypoint_lines[groupLabel].forEach(line => {
                    map.removeLayer(line);
                });
            });

            // 모든 변수를 초기화
            totalWaypoints = [];
            waypoints = [];
            groupCounter = 0;
            pointCounter = 1;
            waypoint_lines = [];
            selectMode = false;

            // 표 정보 초기화
            document.getElementById('waypointBody').innerHTML = ``;
            document.getElementById('detailBody').innerHTML = ``;
            // 표 상태 초기화
            document.getElementById('detailTable').style.display = 'none';

            // waypointLayer와 pathLayer에 각각의 레이어가 존재하는지 확인
            if (waypointLayer) {
                waypointLayer.clearLayers(); // 지도에서 모든 Waypoint 제거
            }
        }
        // Waypoints 삭제 함수
        function deleteWaypoint(label) {
            // 이전 Waypoints를 저장
            totalWaypoints.push(waypoints); // 이를 통해 모든 Icon 제거 가능
            // Waypoints 배열에서 해당 Waypoint 삭제
            const index = totalWaypoints.findIndex(g => g[0].label.startsWith(label.charAt(0)));
            if (index !== -1) {
                // 지도에서 Waypoint 마커 삭제
                totalWaypoints[index].forEach(point => {
                    map.removeLayer(point.marker);
                })
                // Waypoints 배열에서 삭제
                waypoints.splice(index, 1);
                // waypointTable에서 해당 행 제거
                const waypointId = `wt-${label.charAt(0)}`;
                const waypointRow = document.getElementById(waypointId);
                if (waypointRow) {
                    waypointRow.remove();
                }
                // detailTable에서 해당 행 제거
                const detailClassName = `dt-${label.charAt(0)}`;
                const detailRow = document.querySelectorAll(`#detailBody tr.${detailClassName}`);
                if (detailRow) {
                    detailRow.forEach(row => {
                        row.remove();
                    })
                }
                // 선 연결 갱신
                updatePolylines(label);
            }
        }

        // 선 연결 갱신 함수
        function updatePolylines(label) {
            // 삭제되는 Waypoint에 해당되는 선 모두 제거
            waypoint_lines[label.charAt(0)].forEach(line => {
                map.removeLayer(line);
            });
        }

        // 기존 Waypoint를 찾는 함수 (동일 Waypoint 생성용)
        function findNearestWaypoint(latlng, maxDistance = 3) {
            let nearestWaypoint = null;
            let minDistance = maxDistance;

            totalWaypoints.forEach(group => {
                group.forEach(point => {
                    const distance = map.distance(latlng, point.latlng);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestWaypoint = point;
                    }
                });
            });

            return nearestWaypoint;
        }

        // ==================================================================
        //
        //                  Waypoint 정보 및 표 관련 함수
        //
        // ==================================================================
        
        // 표에 Waypoints 정보 추가 함수
        function addWaypointToTable(label, color, robotID) {
            const tbody = document.getElementById('waypointBody');
            const row = document.createElement('tr');
            row.id = `wt-${label.charAt(0)}`;
            if (robotID !== '') {
                row.innerHTML = `
                <td>${label.charAt(0)}</td>
                <td><div class="color-box" style="background-color:${color};"></div></td>
                <td>${robotID}</td>
                <td>${robots[robotID].task}</td>
                <td>${robots[robotID].departure} &#8594; ${robots[robotID].destination}</td>
                <td><button onclick="showDetails('${label}')">Details</button></td>
                <td><button onclick="deleteWaypoint('${label}')">Delete</button></td>
            `;
            }
            else if (robotID === '') {
                row.innerHTML = `
                <td>${label.charAt(0)}</td>
                <td><div class="color-box" style="background-color:${color};"></div></td>
                <td>None</td>
                <td>None</td>
                <td>None</td>
                <td><button onclick="showDetails('${label}')">Details</button></td>
                <td><button onclick="deleteWaypoint('${label}')">Delete</button></td>
            `;
            }
            tbody.appendChild(row);
        }

        // 표에 Waypoints 상세 정보 추가 함수
        function showDetails(label) {
            const detailTable = document.getElementById('detailTable');
            const detailBody = document.getElementById('detailBody');

            // 이미 동일한 Waypoints의 상세 정보가 표시된 경우, 표 상태 전환(게시 -> 숨김)
            if (detailTable.style.display === 'table' && 
                detailBody.firstChild &&
                detailBody.firstChild.querySelector('td').innerText.startsWith(label.charAt(0))) {
                    detailTable.style.display = 'none';
                    return;
            }
            
            // 이전 내용을 제거하고 새 내용을 추가
            detailBody.innerHTML = '';

            // label에 해당되는 Waypoint 찾기
            const group = totalWaypoints.find(g => g[0].label.charAt(0) === label.charAt(0));
            if (!group) return;

            group.forEach(point => {
                const row = document.createElement('tr');
                row.className = `dt-${point.label.charAt(0)}`;
                row.innerHTML = `
                    <td>${point.label}</td>
                    <td>${point.latlng.lat.toFixed(6)}</td>
                    <td>${point.latlng.lng.toFixed(6)}</td>
                    <td>${point.heading.toFixed(6)}</td>
                    <td>
                        <select id="type">
                            <option value="waypoint_follower" ${point.type === 'waypoint_follower' ? 'selected' : ''}>waypoint_follower</option>
                            <option value="navigate_through_poses" ${point.type === 'navigate_through_poses' ? 'selected' : ''}>navigate_through_poses</option>
                        </select>
                    </td>
                `;
                detailBody.appendChild(row);
            });

            // 상세 정보 표 상태 전환(숨김 -> 게시)
            detailTable.style.display = 'table';
        }

        // 두 좌표 사이의 heading을 계산하는 함수
        function calculateHeading(startLatLng, endLatLng) {
            const dx = endLatLng.lng - startLatLng.lng;
            const dy = endLatLng.lat - startLatLng.lat;
            let angle = Math.atan2(dy, dx);

            if (angle < 0) {
                angle += 2 * Math.PI;
            }

            return angle;
        }

        // ==================================================================
        //
        //   Waypoint 저장 및 로드 관련 함수 + WebSocket 함수 + 팝업 관련 함수
        //
        // ==================================================================

        // Waypoint 저장 파일명을 입력하는 함수
        function saveWaypointName() {
            openPopup('yamlFileNamePopup');
            document.getElementById('yamlFileNamePopup').style.display = 'block';
            document.getElementById('overlay').style.display = 'block';
        }

        // Waypoint 저장 파일명을 입력하는 팝업을 닫는 함수
        function closeYamlFileNamePopup() {
            document.getElementById('yamlFileNamePopup').style.display = 'none';
            document.getElementById('overlay').style.display = 'none';
        }

        // Waypoint 저장 목록을 팝업하는 함수
        function saveWaypointFilesPopup() {
            // robot 값이 ''인 Waypoint만 필터링
            const filteredWaypoints = totalWaypoints.filter(group => 
                group.some(waypoint => waypoint.robot === '')
            );

            saveFileListElement.innerHTML = '';
            filteredWaypoints.forEach((waypoints, index) => {
                const labelName = `Label-${waypoints[0].label.charAt(0)}-Waypoint`;

                const li = document.createElement('li');
                
                // 파일 순서 표시
                const orderButton = document.createElement('button');
                orderButton.textContent = index + 1;
                orderButton.disabled = true;

                // 파일 이름 표시
                const fileNameSpan = document.createElement('span');
                fileNameSpan.textContent = labelName;
                fileNameSpan.classList.add('waypoint-label');

                // 파일 선택 버튼
                const selectButton = document.createElement('button');
                selectButton.classList.add('select-button');
                selectButton.textContent = 'Select';

                // 각 요소에 클래스 추가
                orderButton.classList.add('item-space');
                fileNameSpan.classList.add('item-space');

                // 목록 항목에 추가
                li.appendChild(orderButton);
                li.appendChild(fileNameSpan);
                li.appendChild(selectButton);
                saveFileListElement.appendChild(li);

                // 파일 선택 버튼 클릭 이벤트
                selectButton.addEventListener('click', function() {
                    if (selectButton.classList.contains('selected')) {
                        selectButton.classList.remove('selected');
                        saveSelectedWaypoints = [];
                    }
                    else {
                        document.querySelectorAll('.select-button').forEach(btn => {
                            btn.classList.remove('selected');
                        });
                        selectButton.classList.add('selected');
                        saveSelectedWaypoints.push(waypoints);
                    }
                });
            })
        }

        // Waypoint 저장 함수 (YAML 파일 형식)
        function saveWaypoint() {
            const fileName = document.getElementById('newYamlFileName').value;
            document.getElementById('yamlFileNamePopup').style.display = 'none';
            document.getElementById('save-waypoint-popup').style.display = 'none';
            document.getElementById('overlay').style.display = 'none';
            
            // 선택된 값 가져오기
            const task = document.getElementById('task').value;
            const departure = document.getElementById('departure').value;
            const destination = document.getElementById('destination').value;

            // 빈 배열을 선언하여 변환된 데이터를 저장합니다
            const waypointsData = [];

            // totalWaypoints 배열의 각 요소를 순회하며 변환 작업을 수행합니다
            saveSelectedWaypoints.forEach(waypoint => {
                waypoint.forEach(point => {
                    waypointsData.push({
                        label: point.label,
                        color: point.color,
                        latlng: {
                            lat: point.latlng.lat,
                            lng: point.latlng.lng
                        },
                        heading: point.heading,
                        type: point.type
                    });
                })
            });

            // Waypoints 데이터를 한 줄씩 포맷
            const waypointsYamlStr = waypointsData.map(point => {
                return `    - {label: ${point.label}, color: '${point.color}', latlng: {lat: ${point.latlng.lat}, lng: ${point.latlng.lng}}, heading: ${point.heading}, type: ${point.type}}`;
            }).join('\n'); // 각 Waypoint 항목을 한 줄로 포맷하고, 줄바꿈 추가

            // 전체 YAML 구조 (Waypoints는 직접 포맷한 문자열로 추가)
            const yamlStr = `
task: ${task}
departure: ${departure}
destination: ${destination}
waypoints:
${waypointsYamlStr}
            `.trim();

            // 서버로 YAML 파일 전송
            fetch('http://192.168.0.16:3000/api/save-file-origin', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    fileName: fileName,
                    data: yamlStr
                })
            })
            .then(response => response.json())
            .then(data => {
                alert(data.message);
            })
            .catch(error => console.error('Error:', error));

            // 저장 후 선택된 값 초기화
            document.getElementById('task').value = "";
            document.getElementById('departure').value = "";
            document.getElementById('destination').value = "";
            document.getElementById('newYamlFileName').value = "";
        }

        // Waypoint 불러오기 함수 (YAML 파일 형식)
        function loadWaypoints(file, robotID, isFromServer = false) {
            // 서버에서 가져온 YAML 파일의 경우에는 바로 처리
            if (isFromServer) {
                try {
                    const yamlData = file;
        
                    if (!yamlData || !yamlData.waypoints) {
                        throw new Error("Invalid YAML format");
                    }

                    // Reverse 모드 활성화 시에는 역방향의 Waypoint 전송
                    if (reverseMode) {
                        yamlData.waypoints.reverse();
                        yamlData.waypoints.forEach(point => {
                            point.heading = reverseHeading(point.heading);
                        })
                    }
        
                    const yamlContent = jsyaml.dump(yamlData); 
                    console.log("Updated YAML content as string:", yamlContent);
        
                    if (selectedWaypointSocket[robotID].readyState === WebSocket.OPEN) {
                        selectedWaypointSocket[robotID].send(yamlContent);
                        console.log("YAML data sent via WebSocket (Waypoint).");
                    }
                    
                    // 로봇의 주행 경로 초기화
                    selectedRobotWaypoints[robotID] = [];
        
                    // 포인트 카운터 초기화
                    pointCounter = 1;

                    updateRobotInfo(yamlData.task, yamlData.departure, yamlData.destination, robotID);
                    createWaypoint(yamlData.waypoints, robotID);
                } catch (error) {
                    console.error("Failed to load waypoints from YAML:", error);
                    alert("Invalid YAML file. Please check the file format.");
                }
            } else {
                const reader = new FileReader();

                reader.onload = function(event) {
                    try {
                        const yamlData = jsyaml.load(event.target.result);
                        const yamlResult = event.target.result;

                        if (!yamlData || !yamlData.waypoints) {
                            throw new Error("invalid YAML format");
                        }

                        const yamlContent = jsyaml.dump(yamlData); 
                        console.log("Updated YAML content as string:", yamlContent);
                        
                        if (selectedWaypointSocket[robotID].readyState === WebSocket.OPEN) {
                            selectedWaypointSocket[robotID].send(yamlContent);
                            console.log("YAML data sent via WebSocket (Waypoint).");
                            // deadlockDetected[robotID].status = false;
                        }
                        
                        // 로봇의 주행 경로 초기화
                        selectedRobotWaypoints[robotID] = [];
                        
                        // 포인트 카운터 초기화
                        pointCounter = 1;

                        updateRobotInfo(yamlData.task, yamlData.departure, yamlData.destination, robotID);
                        createWaypoint(yamlData.waypoints, robotID);
                    } catch (error) {
                        console.error("Failed to load waypoints from YAML:", error);
                        alert("Invalid YAML file. Please check the file format.");
                    }
                };
                
                reader.readAsText(file);

                // File Input 값을 리셋하여 동일한 파일을 재선택할 수 있음
                const inputFile = document.getElementById("fileInput");
                if (inputFile) {
                    inputFile.value = "";
                }  
            }
        }

        // 서버에서 YAML 파일 목록 불러오는 함수
        function fetchYAMLFiles() {
            fetch('http://192.168.0.16:3000/api/yaml-files')
                .then(response => response.json())
                .then(files => {
                    fileListElement.innerHTML = '';
                    files.forEach((file, index) => {
                        const li = document.createElement('li');
                        li.draggable = true;
                        
                        // 현재 순서 표시
                        const orderButton = document.createElement('button');
                        orderButton.textContent = index + 1;
                        orderButton.disabled = true;

                        // 파일 이름 표시 및 수정
                        const fileNameSpan = document.createElement('span');
                        fileNameSpan.textContent = file;
                        fileNameSpan.onclick = () => selectFile(file);

                        // 파일 시각화 버튼
                        const viewButton = document.createElement('button');
                        viewButton.textContent = 'view';
                        viewButton.onclick = (event) => viewFile(file, event);

                        // 파일명 수정 버튼
                        const renameButton = document.createElement('button');
                        renameButton.textContent = 'rename';
                        renameButton.onclick = () => renameFile(file);

                        // 파일 정보 팝업 버튼
                        const infoButton = document.createElement('button');
                        infoButton.textContent = 'info';
                        infoButton.onclick = () => showWaypointPopup(false, file);

                        // 파일 삭제 버튼
                        const deleteButton = document.createElement('button');
                        deleteButton.textContent = 'delete';
                        deleteButton.onclick = () => openDeletePopup(file);

                        // 각 요소에 클래스 추가
                        orderButton.classList.add('item-space');
                        fileNameSpan.classList.add('item-space');
                        viewButton.classList.add('item-space');
                        renameButton.classList.add('item-space');
                        infoButton.classList.add('item-space');

                        // 목록 항목에 추가
                        li.appendChild(orderButton);
                        li.appendChild(fileNameSpan);
                        li.appendChild(viewButton);
                        li.appendChild(renameButton);
                        li.appendChild(infoButton);
                        li.appendChild(deleteButton);
                        fileListElement.appendChild(li);

                        // 파일 순서 변경
                        li.addEventListener('dragstart', (event) => {
                            event.dataTransfer.setData('text/plain', index);
                        });

                        li.addEventListener('dragover', (event) => {
                            event.preventDefault();
                        });

                        li.addEventListener('drop', (event) => {
                            event.preventDefault(); // 기본 동작을 막아야 정상적으로 drop이 동작함
                            event.stopPropagation(); // 이벤트 전파 방지

                            const oldIndex = event.dataTransfer.getData('text/plain');
                            const newIndex = index;

                            console.log(`oldIndex: ${oldIndex}, newIndex: ${newIndex}`); // 로그로 확인

                            if (oldIndex !== newIndex) {
                                swapFiles(oldIndex, newIndex);
                            }
                        });
                    });
                })
                .catch(error => {
                    console.error('Error fetching file list:', error);
                    fileListElement.innerHTML = 'An error occurred while retrieving the file list.'
                });
        }

        // Waypoint를 역방향으로 변환하는 함수
        function toggleReverseMode() {
            reverseMode = !reverseMode;
            const reverseButton = document.getElementById('reverseButton');

            if (reverseMode) {
                reverseButton.textContent = 'Reverse Mode ON';
                alert('Reverse mode activated!');
            }
            else {
                reverseButton.textContent = 'Reverse Mode OFF';
                alert('Reverse mode deactivated!');
            }
        }

        // 역방향 모드일 때 각 Point에서의 방향을 역방향으로 변환하는 함수
        function reverseHeading(heading) {
            return (heading + Math.PI) % (2 * Math.PI);
        }

        // 파일 시각화 함수
        function viewFile(fileName, event) {
            viewFileMode = !viewFileMode;

            if (viewFileMode) {
                fetch(`http://192.168.0.16:3000/api/yaml-files/${fileName}`)
                    .then(response => response.json())
                    .then(fileContent => {                                    
                        // 팝업용 Waypoint 생성
                        createWaypointPopup(fileContent.waypoints);

                        // 팝업용 지도 표시
                        const rect = event.target.getBoundingClientRect();
                        const mapPopupElement = document.getElementById('mapPopup');
                        mapPopupElement.style.display = 'block';
                        mapPopupElement.style.left = `50%`;
                        mapPopupElement.style.top = `${rect.bottom + 150}px`; // 클릭 위치 바로 아래로 10px 이동

                        // 팝업 지연에 맞추어 타이머 설정
                        setTimeout(() => {
                            // 팝업용 지도 크기 재조정
                            mapPopup.invalidateSize();
                        }, 200);
                    })
                    .catch(error => {
                        console.error('Error loading file:', error);
                    });
            }
            else if (!viewFileMode) {
                fetch(`http://192.168.0.16:3000/api/yaml-files/${fileName}`)
                    .then(response => response.json())
                    .then(fileContent => {
                        // 팝업용 지도에서 모든 Waypoints 제거
                        mapPopupWaypoints.forEach(point => {
                            mapPopup.removeLayer(point.marker);
                        });

                        // 팝업용 지도에서 모든 Waypoints Lines 제거
                        popupWaypoint_lines.forEach(line => {
                            mapPopup.removeLayer(line);
                        });

                        // 팝업용 Waypoints 초기화
                        mapPopupWaypoints = [];
                        popupWaypoint_lines = [];

                        // 팝업용 지도 숨김
                        document.getElementById('mapPopup').style.display = 'none';
                    })
                    .catch(error => {
                        console.error('Error loading file:', error);
                    });
            }
        }

        // 파일명 수정 함수
        function renameFile(oldFileName) {
            const newFileName = prompt('Enter new file name:', oldFileName);
            if (newFileName) {
                fetch(`http://192.168.0.16:3000/api/rename-file`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ oldFileName: oldFileName, newFileName: newFileName })
                })
                .then(response => response.json())
                .then(data => {
                    console.log(data.message);
                    alert(data.message);
                    fetchYAMLFiles();
                })
                .catch(error => console.error('Error:', error));
            }
        }

        // 파일 순서 변경 함수
        function swapFiles(oldIndex, newIndex) {
            fetch(`http://192.168.0.16:3000/api/swap-files`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ oldIndex: oldIndex, newIndex: newIndex })
            })
            .then(response => response.json())
            .then(data => {
                console.log(data.message);
                fetchYAMLFiles();
            })
            .catch(error => console.error('Error:', error));
        }

        // YAML 파일 목록 선택 함수
        function selectFile(fileName) {
            fetch(`http://192.168.0.16:3000/api/yaml-files/${fileName}`)
                .then(response => response.json())
                .then(fileContent => {
                    console.log(`Selected File: ${fileName}`);
                    
                    // Waypoint Load 함수 실행
                    loadWaypoints(fileContent, selectedRobotID, true);

                    // 팝업 닫기
                    waypointPopup.style.display = 'none';
                    overlay.style.display = 'none';
                })
                .catch(error => {
                    console.error('Error loading file:', error);
                });
        }

        // YAML 파일 삭제 확인 팝업 함수
        function openDeletePopup(fileName) {
            document.getElementById('deleteConfirmationPopup').style.display = 'flex';
            deleteYamlFileName = fileName;
        }

        // YAML 파일 삭제 확인 팝업 닫는 함수
        function cancelDelete() {
            document.getElementById('deleteConfirmationPopup').style.display = 'none';
            deleteYamlFileName = null;
        }

        // YAML 파일 삭제 함수
        function deleteFile() {
            const fileName = deleteYamlFileName;

            fetch('http://192.168.0.16:3000/api/delete-file', {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ fileName })
            })
            .then(response => response.json())
            .then(data => {
                document.getElementById('deleteConfirmationPopup').style.display = 'none';
                deleteYamlFileName = null;
                alert(data.message);
                fetchYAMLFiles();
            })
            .catch(error => console.error('Error:', error));
        }

        // Waypoint Point 정보 팝업 함수
        function showWaypointPopup(useCurrentData = true, fileName = null) {

            if (!useCurrentData && fileName) {
                // 서버에서 파일 불러오기
                fetch(`http://192.168.0.16:3000/api/yaml-files/${fileName}`)
                    .then(response => response.json())
                    .then(fileContent => {
                        console.log(`Selected File: ${fileName}`);
                        setCurrentYamlData(fileContent);
                        updateWaypointList(fileContent);
                        document.getElementById('waypoint-popup2').dataset.name = fileName;
                    })
                    .catch(error => {
                        console.error('Error loading file:', error);
                    });
            }
            else {
                // 수정된 파일 내용을 사용하기
                updateWaypointList(currentYamlData);
            }
            openPopup('waypoint-popup2');
            document.getElementById('waypoint-popup2').style.display = 'block';
        }

        // Waypoint Point 정보 목록을 업데이트하는 함수
        function updateWaypointList(fileContent) {
            const waypointListElement = document.getElementById('waypointList');
            waypointListElement.innerHTML = '';

            fileContent.waypoints.forEach((point, index) => {
                const li = document.createElement('li');
                li.innerHTML = `
                    <strong>${point.label}</strong>
                    <ul>
                        <li>Latitude: ${point.latlng.lat}</li>
                        <li>Longitude: ${point.latlng.lng}</li>
                        <li>Heading: ${point.heading}</li>
                    </ul>
                    <button onclick="editWaypoint(${index})">Edit</button>
                    <button onclick="deleteWaypoint(${index})">Delete</button>
                `;
                waypointListElement.appendChild(li);
            });
        }

        // Waypoint Point 정보 팝업을 닫는 함수
        function closeWaypointPopup() {
            document.getElementById('waypoint-popup2').style.display = 'none';
        }

        // YAML 데이터를 저장하는 함수
        function setCurrentYamlData(yamlData) {
            currentYamlData = yamlData;
        }

        // Waypoint Point 수정 함수
        function editWaypoint(index) {
            const yamlData = currentYamlData;
            const point = yamlData.waypoints[index];

            // 팝업창에 기존 값 세팅
            document.getElementById('latInput').value = point.latlng.lat;
            document.getElementById('lngInput').value = point.latlng.lng;
            document.getElementById('headingInput').value = point.heading;

            // 저장 시에 사용할 index도 함께 저장
            document.getElementById('editFormPopup').dataset.index = index;

            // 팝업창 열기
            openPopup('editFormPopup');
            document.getElementById('editFormPopup').style.display = 'block';
        }

        // Point 수정 후 저장 버튼 클릭 시 수정된 값을 반영하는 함수
        function saveEditedWaypoint() {
            const index = document.getElementById('editFormPopup').dataset.index;
            const yamlData = currentYamlData;
            const point = yamlData.waypoints[index];

            // 수정된 값들 가져오기
            point.latlng.lat = parseFloat(document.getElementById('latInput').value);
            point.latlng.lng = parseFloat(document.getElementById('lngInput').value);
            point.heading = parseFloat(document.getElementById('headingInput').value);

            console.log(yamlData);
            // 팝업창 닫은 후 데이터 업데이트
            closeEditPopup();
            showWaypointPopup(true);
        }

        // Waypoint Point 팝업창 닫는 함수
        function closeEditPopup() {
            document.getElementById('editFormPopup').style.display = 'none';
        }

        // Waypoint Point 삭제 함수
        function deleteWaypoint(index) {
            const yamlData = currentYamlData;
            const prefix = yamlData.waypoints[0].label.charAt(0);

            // Point 삭제
            yamlData.waypoints.splice(index, 1);

            // 삭제 후 라벨을 재정렬
            yamlData.waypoints.forEach((point, i) => {
                point.label = `${prefix}-${i + 1}`;
            })

            showWaypointPopup(true);
        }

        // Waypoint Point 추가용 팝업 페이지 여는 함수
        function openPointPopup() {
            const fileName = document.getElementById('waypoint-popup2').dataset.name;

            fetch(`http://192.168.0.16:3000/api/yaml-files/${fileName}`)
                                .then(response => response.json())
                                .then(fileContent => {                                    
                                    // 팝업용 Waypoint 생성
                                    createWaypointPointPopup(fileContent.waypoints);

                                    // 팝업용 지도(Point 추가) 표시
                                    openPopup('mapPopupPointPage');
                                    const mapPopupPointPageElement = document.getElementById('mapPopupPointPage');
                                    mapPopupPointPageElement.style.display = 'block';

                                    // 팝업 지연에 맞추어 타이머 설정
                                    setTimeout(() => {
                                        // 팝업용 지도 크기 재조정
                                        const mapPopupPointElement = document.getElementById('mapPopupPoint');
                                        mapPopupPoint.invalidateSize();
                                    }, 200);
                                })
                                .catch(error => {
                                    console.error('Error loading file:', error);
                                });
        }

        // Waypoint Point 추가용 팝업 페이지 닫는 함수
        function closeMapPopupPoint() {
            document.getElementById('mapPopupPointPage').style.display = 'none';

            // 변수 및 객체 초기화
            popupPointCounter = 1;
            pointLineMode = true;
            addPointMode = false;
            mapPopupPointWaypoints = [];
            popupPointWaypoint_lines = [];

            document.getElementById('point_index').value = '';

            // 업데이트
            showWaypointPopup(true);
        }

        // Waypoint Point 추가 함수
        function addPoint() {
            addPointMode = !addPointMode;
            const yamlData = currentYamlData;

            if (addPointMode) {
                // addPointMode가 true일 때 이벤트 리스너 활성화
                mapPopupPoint.on('mousedown', onMouseDown);
                mapPopupPoint.on('mousemove', onMouseMove);
                mapPopupPoint.on('mouseup', function(e) {
                    onMouseUp(e, yamlData);
                });
            } else {
                // addPointMode가 false일 때 이벤트 리스너 제거
                mapPopupPoint.off('mousedown', onMouseDown);
                mapPopupPoint.off('mousemove', onMouseMove);
                mapPopupPoint.off('mouseup', function(e) {
                    onMouseUp(e, yamlData);
                });
            }            
        }

        // mousedown 이벤트 핸들러
        function onMouseDown(e) {
            if (e.originalEvent.button === 0) {
                isDragging = true;
                startLatLng = e.latlng;

                e.originalEvent.preventDefault();
                e.originalEvent.stopPropagation();

                mapPopupPoint.dragging.disable();

                tempMarker = L.marker(startLatLng, {
                    icon: L.divIcon({
                        className: 'custom-div-icon',
                        html: '<img src="robot_1.png" alt="Custom Icon"/>',
                        iconSize: [15, 15],
                    }),
                    draggable: false,
                }).addTo(mapPopupPoint);
            } else if (e.originalEvent.button === 1) {
                mapPopupPoint.dragging.enable();
            }
        }

        // mousemove 이벤트 핸들러
        function onMouseMove(e) {
            if (!isDragging) return;

            e.originalEvent.preventDefault();
            e.originalEvent.stopPropagation();

            const currentLatLng = e.latlng;
            const angle = calculateHeading(startLatLng, currentLatLng);

            tempMarker.setLatLng(startLatLng);

            const arrowElement = tempMarker.getElement().querySelector('img');
            arrowElement.style.transform = `rotate(${1.57 - angle}rad)`;
        }

        // mouseup 이벤트 핸들러
        function onMouseUp(e, yamlData) {
            if (!isDragging) return;
            isDragging = false;

            e.originalEvent.preventDefault();
            e.originalEvent.stopPropagation();

            const pointColor = yamlData.waypoints[0].color;
            const pointType = yamlData.waypoints[0].type;

            const endLatLng = e.latlng;
            const label = '';
            const heading = calculateHeading(startLatLng, endLatLng);

            let waypointToUse = findNearestWaypoint(startLatLng);

            if (waypointToUse) {
                startLatLng = waypointToUse.latlng;
            }

            const waypoint = L.marker(startLatLng, {
                title: label,
                icon: L.divIcon({
                    className: 'custom-div-icon',
                    html: '<img src="robot_1.png" alt="Custom Icon"/>',
                    iconSize: [15, 15],
                }),
                draggable: false,
            }).addTo(mapPopupPoint);

            const arrowElement = waypoint.getElement().querySelector('img');
            arrowElement.style.transform = `rotate(${1.57 - heading}rad)`;

            waypoint.label = label;
            waypoint.color = pointColor;
            waypoint.latlng = startLatLng;
            waypoint.heading = heading;
            waypoint.type = pointType;

            addPopupWaypoints.push({
                marker: waypoint,
                color: pointColor,
                latlng: startLatLng,
                label: label,
                heading: heading,
                type: pointType
            });

            mapPopupPoint.dragging.enable();
            mapPopupPoint.removeLayer(tempMarker);
        }

        // Waypoint Point 추가용 팝업 페이지에서 추가된 Point 저장 함수
        function saveMapPopupPoint() {
            const yamlData = currentYamlData;
            const index = document.getElementById('point_index').value;
            const waypointsData = [];

            addPopupWaypoints.forEach(point => {
                waypointsData.push({
                    label: point.label,
                    color: point.color,
                    latlng: {
                        lat: point.latlng.lat,
                        lng: point.latlng.lng
                    },
                    heading: point.heading,
                    type: point.type
                });
            });

            // Waypoints 데이터 삽입
            insertPointToYaml(yamlData, waypointsData[0], index);

            // 팝업 종료
            closeMapPopupPoint();
        }

        // 추가된 Point를 YAML 데이터에 삽입하는 함수
        function insertPointToYaml(yamlData, newPoint, index) {
            // 1. Waypoints 배열에서 삽입 위치를 기준으로 새로운 데이터 삽입
            yamlData.waypoints.splice(index, 0, newPoint);

            // 2. 라벨과 순서를 다시 재정렬
            const label = yamlData.waypoints[0].label.charAt(0);
            
            yamlData.waypoints.forEach((point, index) => {
                point.label = `${label}-${index + 1}`;
            });
        }

        // Waypoint Point 추가용 팝업 페이지에서 추가된 Point 취소 함수
        function cancelPoint() {
            // 팝업용 지도(Point 추가)에서 추가된 Points 제거
            addPopupWaypoints.forEach(point => {
                mapPopupPoint.removeLayer(point.marker);
            });

            // 변수 초기화
            addPopupWaypoints = [];
        }

        // Waypoint Point 추가용 팝업 페이지에서 Line 시각화 제어 함수
        function togglePointLine() {
            // 팝업용 지도(Point 추가)의 Waypoint Line 시각화 모드 토글
            pointLineMode = !pointLineMode;

            if (!pointLineMode) {
                // 팝업용 지도(Point 추가)에서 모든 Waypoints Lines 제거
                popupPointWaypoint_lines.forEach(line => {
                    mapPopupPoint.removeLayer(line);
                });
            }
            else {
                // 팝업용 지도(Point 추가)에서 모든 Waypoints Lines 생성
                popupPointWaypoint_lines.forEach(line => {
                    line.addTo(mapPopupPoint);
                });
            }
        }

        // Waypoint YAML 파일 덮어쓰는 함수
        function overwriteWaypoint() {
            const yamlData = currentYamlData;
            const fileName = document.getElementById('waypoint-popup2').dataset.name;

            fetch('http://192.168.0.16:3000/api/overwrite-file', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ fileName: fileName, data: yamlData })
            })
            .then(response => response.json())
            .then(data => {
                alert(data.message);
                document.getElementById('waypoint-popup2').style.display = 'none';
            })
            .catch(error => console.error('Error:', error));
        }

        // 새로운 파일명을 입력하는 팝업을 생성하는 함수
        function openFileNamePopup() {
            openPopup('fileNamePopup');
            document.getElementById('fileNamePopup').style.display = 'block';
        }

        // Waypoint YAML 파일 새로 생성해서 저장하는 함수
        function saveAsNew() {
            const newFileName = document.getElementById('newFileName').value;

            if (!newFileName) {
                alert("Please enter a new file name.");
                return;
            }

            document.getElementById('fileNamePopup').style.display = 'none';

            const yamlData = currentYamlData;

            fetch('http://192.168.0.16:3000/api/save-file', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ fileName: newFileName, data: yamlData })
            })
            .then(response => response.json())
            .then(data => {
                alert(data.message);
                document.getElementById('waypoint-popup2').style.display = 'none';
                fetchYAMLFiles();
            })
            .catch(error => console.error("Error:", error));
        }

        // 팝업 닫기
        function closeFileNamePopup() {
            document.getElementById('fileNamePopup').style.display = 'none';
        }

        // Waypoint 생성 함수 (YAML 파일 형식)
        function createWaypoint(yaml_waypoints, robotID) {
            if (Array.isArray(yaml_waypoints)) {
                yaml_waypoints.forEach(point => {

                    // Waypoint 구분
                    if (pointCounter === 1) {
                        // 작업 중인 Waypoint가 있는 경우
                        if (waypoints.length > 0) {
                            startNewGroup();
                        }
                        tempLabel = point.label.charAt(0);
                    }
                    // YAML 파일 내에 2개 이상의 Waypoint가 있는 경우
                    else if (pointCounter !== 1) {
                        if (point.label.charAt(0) !== tempLabel) {
                            startNewGroup();
                            tempLabel = point.label.charAt(0);
                        }
                    }

                    const waypoint = L.marker(point.latlng, {
                        title: point.label,
                        icon: L.divIcon({ 
                            className: 'custom-div-icon',
                            html: '<img src="robot_1.png" alt="Custom Icon"/>',
                            iconSize: [15, 15],
                        }),
                        draggable: false,
                    }).addTo(map);

                    const arrowElement = waypoint.getElement().querySelector('img');
                    arrowElement.style.transform = `rotate(${1.57-point.heading}rad)`;

                    waypoint.label = point.label;
                    waypoint.color = point.color;
                    waypoint.latlng = point.latlng;
                    waypoint.heading = point.heading;
                    waypoint.type = point.type;
                    waypoint.destination = '';
                    waypoint.robot = robotID;

                    waypoints.push({ 
                        marker: waypoint, 
                        color: point.color, 
                        latlng: point.latlng, 
                        label: point.label,
                        heading: point.heading,
                        type: point.type,
                        destination: '',
                        robot: robotID
                    });

                    selectedRobotWaypoints[robotID].push({
                        label: point.label,
                        latlng: point.latlng,
                        heading: point.heading,
                        type: point.type
                    });

                    if (waypoints.length > 1) {
                        const previousWaypoint = waypoints[waypoints.length - 2].marker.getLatLng();
                        const polyline = L.polyline([previousWaypoint, point.latlng], { color: point.color }).addTo(map);

                        if (!waypoint_lines[point.label.charAt(0)]){
                            waypoint_lines[point.label.charAt(0)] = [];
                        }
                        waypoint_lines[point.label.charAt(0)].push(polyline);
                    }

                    if (pointCounter === 1) addWaypointToTable(point.label, point.color, robotID);
            
                    pointCounter++;
                });

                // Waypoint 업데이트
                startNewGroup()
            } else {
                console.error('Invalid waypoints data format');
            }
        }

        // 팝업용 Waypoint 생성 함수 - 팝업용 지도
        function createWaypointPopup(yaml_waypoints) {
            if (Array.isArray(yaml_waypoints)) {
                yaml_waypoints.forEach(point => {

                    // Waypoint 구분
                    if (pointCounter === 1) {
                        tempLabel = point.label.charAt(0);
                    }
                    // YAML 파일 내에 2개 이상의 Waypoint가 있는 경우
                    else if (pointCounter !== 1) {
                        if (point.label.charAt(0) !== tempLabel) {
                            tempLabel = point.label.charAt(0);
                        }
                    }

                    const waypoint = L.marker(point.latlng, {
                        title: point.label,
                        icon: L.divIcon({ 
                            className: 'custom-div-icon',
                            html: '<img src="robot_1.png" alt="Custom Icon"/>',
                            iconSize: [15, 15],
                        }),
                        draggable: false,
                    }).addTo(mapPopup);

                    const arrowElement = waypoint.getElement().querySelector('img');
                    arrowElement.style.transform = `rotate(${1.57-point.heading}rad)`;

                    waypoint.label = point.label;
                    waypoint.color = point.color;
                    waypoint.latlng = point.latlng;
                    waypoint.heading = point.heading;
                    waypoint.type = point.type;

                    mapPopupWaypoints.push({ 
                        marker: waypoint, 
                        color: point.color, 
                        latlng: point.latlng, 
                        label: point.label,
                        heading: point.heading,
                        type: point.type,
                    });

                    if (mapPopupWaypoints.length > 1) {
                        const previousWaypoint = mapPopupWaypoints[mapPopupWaypoints.length - 2].marker.getLatLng();
                        const polyline = L.polyline([previousWaypoint, point.latlng], { color: point.color }).addTo(mapPopup);

                        popupWaypoint_lines.push(polyline);
                    }
                });
            } else {
                console.error('Invalid waypoints data format');
            }
        }

        // 팝업용 Waypoint 생성 함수 - 팝업용 지도(Point 추가)
        function createWaypointPointPopup(yaml_waypoints) {
            if (Array.isArray(yaml_waypoints)) {
                yaml_waypoints.forEach(point => {

                    // Waypoint 구분
                    if (popupPointCounter === 1) {
                        tempLabel = point.label.charAt(0);
                    }
                    // YAML 파일 내에 2개 이상의 Waypoint가 있는 경우
                    else if (popupPointCounter !== 1) {
                        if (point.label.charAt(0) !== tempLabel) {
                            tempLabel = point.label.charAt(0);
                        }
                    }

                    const waypoint = L.marker(point.latlng, {
                        title: point.label,
                        icon: L.divIcon({ 
                            className: 'custom-div-icon',
                            html: `<div class="circle-icon">${popupPointCounter}</div>`,
                            iconSize: [15, 15],
                        }),
                        draggable: false,
                    }).addTo(mapPopupPoint);

                    const arrowElement = waypoint.getElement().querySelector('div');
                    arrowElement.style.transform = `rotate(${1.57-point.heading}rad)`;

                    waypoint.label = point.label;
                    waypoint.color = point.color;
                    waypoint.latlng = point.latlng;
                    waypoint.heading = point.heading;
                    waypoint.type = point.type;

                    mapPopupPointWaypoints.push({ 
                        marker: waypoint, 
                        color: point.color, 
                        latlng: point.latlng, 
                        label: point.label,
                        heading: point.heading,
                        type: point.type,
                    });

                    if (mapPopupPointWaypoints.length > 1) {
                        const previousWaypoint = mapPopupPointWaypoints[mapPopupPointWaypoints.length - 2].marker.getLatLng();
                        const polyline = L.polyline([previousWaypoint, point.latlng], { color: point.color }).addTo(mapPopupPoint);

                        popupPointWaypoint_lines.push(polyline);
                    }

                    popupPointCounter++;
                });
            } else {
                console.error('Invalid waypoints data format');
            }
        }

        // "Control Mode" 버튼 클릭 시 호출되는 함수
        function toggleControlMode() {
            controlMode = !controlMode;

            if (controlMode) {
                alert('Control Mode is now ON. Click on the point you want.');
            }
            else {
                alert('Control Mode is now OFF.');
            }
        }

        // 로봇 Speed 업데이트 팝업 함수
        function speedUpdatePopup() {
            document.getElementById('overlay').style.display = 'block';
            document.getElementById('speedUpdatePopup').style.display = 'block';
        }

        // 로봇 Speed 업데이트 팝업 닫는 함수
        function closeSpeedUpdatePopup() {
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('speedUpdatePopup').style.display = 'none';

            document.getElementById('robotSpeed').value = '';
        }

        // 로봇 Speed 업데이트 함수
        function updateRobotSpeed() {
            const robotID = selectedRobotID;
            const speed = document.getElementById('robotSpeed').value.trim();

            // 로봇 speed 값의 유효성 검사
            if (isNaN(speed) || speed < 0) {
                console.log("Invalid speed input. Please enter a positive number.");
                return;
            }

            document.getElementById('overlay').style.display = 'none';
            document.getElementById('speedUpdatePopup').style.display = 'none';

            document.getElementById('robotSpeed').value = '';

            // JSON 데이터 생성
            const data = JSON.stringify({ speed: parseFloat(speed) });

            // WebSocket (Speed) 연결 상태 확인 후 속도 데이터 송신
            if (selectedSpeedSocket[robotID].readyState === WebSocket.OPEN) {
                selectedSpeedSocket[robotID].send(data);
                console.log(`Robot ${robotID} speed sent via WebSocket (Speed): ${speed}`);
            }
            else {
                console.log("WebSocket (Speed) connection is not open.");
            }

            // Robot Speed 값을 초기화
            const inputSpeed = document.getElementById("robotSpeed");
            if (inputSpeed) {
                inputSpeed.value = "";
            }  
        }

        // 로봇 원격 제어 팝업 함수
        function robotController() {
            if (selectedRobotID === null) {
                alert("No robots selected.");
                return;
            }
            
            document.getElementById('controllerPopup').style.display = 'flex';
        }

        // 속도 조절 함수
        function adjustSpeed(type, value) {
            const robot = robots[selectedRobotID];

            if (type === 'linear') {
                // 선속도 업데이트, 최대 0.5, 음수 방지
                robot.remoteLinearSpeed = Math.max(0, Math.min(0.5, robot.remoteLinearSpeed + value));
                document.getElementById('linearSpeedDisplay').textContent = robot.remoteLinearSpeed.toFixed(2);
            } else if (type === 'angular') {
                // 각속도 업데이트, 최대 1.0, 음수 방지
                robot.remoteAngularSpeed = Math.max(0, Math.min(1.0, robot.remoteAngularSpeed + value));
                document.getElementById('angularSpeedDisplay').textContent = robot.remoteAngularSpeed.toFixed(2);
            }

            // 이미 명령을 실행하고 있을 시에는 업데이트된 속도로 재명령
            if (robot.remoteCommandState !== 'stop') {
                sendControl(robot.remoteCommandState);
            }
        }

        // 로봇 조작 명령을 WebSocket으로 전송
        function sendControl(command) {
            const robot = robots[selectedRobotID];
            
            robot.remoteCommandState = command;

            if (selectedRemoteSocket[selectedRobotID].readyState === WebSocket.OPEN) {
                const commandData = JSON.stringify({
                    command: robot.remoteCommandState,
                    linear_speed: robot.remoteLinearSpeed,
                    angular_speed: robot.remoteAngularSpeed
                });
                selectedRemoteSocket[selectedRobotID].send(commandData);
                console.log(`명령 전송: ${command}`);
            } else {
                console.log("WebSocket 연결이 닫혀있습니다.");
            }
        }

        // 로봇 원격 제어 팝업 닫는 함수
        function closeControllerPopup() {
            document.getElementById('controllerPopup').style.display = 'none';
        }

        // 팝업창에 드래그 기능을 추가하는 함수
        function makeElementDraggable(popupId, headerClass) {
            const popup = document.getElementById(popupId);
            const header = popup.querySelector(headerClass);
        
            let posX = 0, posY = 0, mouseX = 0, mouseY = 0;
        
            header.onmousedown = dragMouseDown;
        
            function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
        
                mouseX = e.clientX;
                mouseY = e.clientY;
        
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }
        
            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
        
                posX = mouseX - e.clientX;
                posY = mouseY - e.clientY;
                mouseX = e.clientX;
                mouseY = e.clientY;
        
                popup.style.top = (popup.offsetTop - posY) + "px";
                popup.style.left = (popup.offsetLeft - posX) + "px";
            }
        
            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }
        
        // 팝업 열기 함수
        function openPopup(popupId) {
            document.getElementById('overlay').style.display = 'block'; // 배경 어둡게 처리
            const popup = document.getElementById(popupId);
            popup.style.display = 'block'; // 팝업 창 열기
        
            // 팝업을 드래그 가능하게 설정
            makeElementDraggable(popupId, '.popup-header');
        }
        
        // 팝업 닫기 함수
        function closePopup(popupId) {
            document.getElementById('overlay').style.display = 'none'; // 배경 숨기기
            document.getElementById(popupId).style.display = 'none'; // 팝업 창 숨기기
        }

        // ==================================================================
        //
        //                    로봇 세팅 및 상태 시각화 함수
        //
        // ==================================================================

        // "Add Robot" 버튼 클릭 시 입력창 팝업
        function addRobotPopup() {
            openPopup('addRobotPopup');
            document.getElementById('addRobotPopup').style.display = 'block';
        }

        // 로봇 ID & IP 입력창 팝업 닫는 함수
        function closeAddRobotPopup() {
            document.getElementById('robotID').value = '';
            document.getElementById('robotIP').value = '';
            document.getElementById('addRobotPopup').style.display = 'none';
            document.getElementById('overlay').style.display = 'none';
        }

        // "Add Robot" 버튼 클릭 시 호출되는 함수
        function addRobotFromInput() {
            const robotID = document.getElementById('robotID').value.trim();
            const robotIP = document.getElementById('robotIP').value.trim();
            if (robotID && robotIP) {
                addRobot(robotID, robotIP);
                addRobotInfoPopup(robotID);
                initializeMatrix();
                document.getElementById('robotID').value = '';
                document.getElementById('robotIP').value = '';
                document.getElementById('addRobotPopup').style.display = 'none';
                document.getElementById('overlay').style.display = 'none';
            } 
            else {
                if (!robotID) {
                    alert('Please input the Robot ID.');
                }
                else if (!robotIP) {
                    alert('Please input the Robot IP.');
                }
            }
        }

        // 로봇을 추가하는 함수
        function addRobot(id, ip) {
            if (!robots[id]) {
                robots[id] = {
                    id: id,
                    statusSocket: setupWebSocket(
                        `ws://${ip}:9000`,
                        () => {
                            robots[id].statusSocket = setupWebSocket(`ws://${ip}:9000`, () => {}, id, 'status');
                            setupStatusSocket(id);
                        },
                        id,
                        'status'
                    ),
                    waypointSocket: setupWebSocket(
                        `ws://${ip}:8000`,
                        () => robots[id].waypointSocket = setupWebSocket(`ws://${ip}:8000`, () => {}, id, 'waypoint'),
                        id,
                        'waypoint'
                    ),
                    controlSocket: setupWebSocket(
                        `ws://${ip}:7000`,
                        () => robots[id].controlSocket = setupWebSocket(`ws://${ip}:7000`, () => {}, id, 'control'),
                        id,
                        'control'
                    ),
                    speedSocket: setupWebSocket(
                        `ws://${ip}:7500`,
                        () => robots[id].speedSocket = setupWebSocket(`ws://${ip}:7500`, () => {}, id, 'speed'),
                        id,
                        'speed'
                    ),
                    remoteSocket: setupWebSocket(
                        `ws://${ip}:8500`,
                        () => robots[id].remoteSocket = setupWebSocket(`ws://${ip}:8500`, () => {}, id, 'remote'),
                        id,
                        'remote'
                    ),
                    lat: 38.161479,
                    lng: -122.454630,
                    heading: 0,
                    task: '',
                    departure: '',
                    destination: '',
                    speed: 0,
                    priority: '',
                    remoteCommandState: 'stop',
                    remoteLinearSpeed: linearSpeed,
                    remoteAngularSpeed: angularSpeed,
                    marker: L.marker([34.9682601, 127.4821126], {
                        icon: L.divIcon({
                            className: 'robot',
                            html: `<div>🤖 ${id}</div>`,
                            iconSize: [30, 30]
                        })
                    }).addTo(map)
                };
                // 로봇 상태 설정
                setupStatusSocket(id);
                // 드롭다운에 로봇 추가
                addRobotToDropdown(id);
                console.log(`Robot ${id} added and listed in Dropdown.`);
            }
        }

         // WebSocket 연결을 생성하고 끊어지면 재연결
         function setupWebSocketForStatus(url, reconnect, id) {
            const socket = new WebSocket(url);
            
            socket.onopen = () => console.log(`WebSocket 연결 성공: ${url}`);
            socket.onclose = () => {
                console.log(`WebSocket 연결 끊김: ${url} - 재연결 시도 중...`);
                setTimeout(() => {
                    reconnect();
                     // statusSocket일 때만 재실행
                }, 5000); // 5초 후 재연결 시도
            };
            socket.onerror = (error) => console.log(`WebSocket 오류: ${url}`, error);

            return socket;
        }

        // WebSocket 연결을 생성하고 끊어지면 재연결
        function setupWebSocket(url, onReconnect, id, socketType) {
            const socket = new WebSocket(url);
            
            socket.onopen = () => {
                console.log(`WebSocket 연결 성공: ${url}`);
            }
            socket.onclose = () => {
                console.log(`WebSocket 연결 끊김: ${url} - 재연결 시도 중...`);
                setTimeout(() => {
                    const newSocket = setupWebSocket(url, onReconnect, id, socketType);
                    
                    // 재연결 후 새 WebSocket 인스턴스를 해당 로봇의 selectedSocket에 갱신
                    if (socketType === 'waypoint') {
                        selectedWaypointSocket[id] = newSocket;
                    }
                    else if (socketType === 'control') {
                        selectedControlSocket[id] = newSocket;
                    }
                    else if (socketType === 'speed') {
                        selectedSpeedSocket[id] = newSocket;
                    }
                    else if (socketType === 'remote') {
                        selectedRemoteSocket[id] = newSocket;
                    }
                    else if (socketType === 'status') {
                        robots[id].statusSocket = newSocket;
                        setupStatusSocket(id);
                    }

                }, 5000); // 5초 후 재연결 시도
            };
            socket.onerror = (error) => console.log(`WebSocket 오류: ${url}`, error);
        
            return socket;
        }

        // 로봇의 상태를 시각화하는 함수
        function setupStatusSocket(id) {
            const robot = robots[id];
            robot.statusSocket.onmessage = function (event) {
                let data = JSON.parse(event.data.replace(/status_data:\s*/g, '"status_data":'));
                let statusData = JSON.parse(data.status_data);
                let gps = statusData.gps;
                let heading = statusData.heading;
                let speed = statusData.speed;

                if (gps && gps.latitude !== undefined && gps.longitude !== undefined && heading !== undefined) {
                    robot.marker.setLatLng([gps.latitude, gps.longitude]);
                    robot.lat = gps.latitude;
                    robot.lng = gps.longitude;
                    robot.heading = heading;
                    robot.speed = speed;

                    // 현재 위치를 기반으로 로봇의 waypoint 추적
                    trackRobotWaypoint(robot);
                    // 로봇의 주행 거리와 시간을 업데이트
                    updateDistanceAndTime(robot);
                    // 로봇간의 교착 확률 계산 및 시각화
                    updateMatrix();
                }

                let path = statusData.path;
                if (Array.isArray(path) && path.length > 0) {
                    let LatLngs = path.map(point => [point.latitude, point.longitude]);

                    if (robot.pathLine) {
                        map.removeLayer(robot.pathLine);
                    }

                    robot.pathLine = L.polyline(LatLngs, { color: 'red' }).addTo(map);
                }
            };
        }

        // 로봇을 드롭다운 메뉴에 추가하는 함수
        function addRobotToDropdown(id) {
            const dropdown = document.getElementById('robotDropdown');
            const option = document.createElement('option');
            option.value = id;
            option.text = id;
            dropdown.add(option);
        }

        // 드롭다운의 값이 변경될 때마다 웹소켓을 업데이트하는 함수
        function updateSelectedRobot() {
            selectedRobotID = document.getElementById('robotDropdown').value;
            if (selectedRobotID && robots[selectedRobotID]) {
                const selectedRobot = robots[selectedRobotID];
                selectedWaypointSocket[selectedRobotID] = selectedRobot.waypointSocket;
                selectedControlSocket[selectedRobotID] = selectedRobot.controlSocket;
                selectedSpeedSocket[selectedRobotID] = selectedRobot.speedSocket;
                selectedRemoteSocket[selectedRobotID] = selectedRobot.remoteSocket;
                console.log(`Selected robot: ${selectedRobotID}`);
            } else {
                // 선택된 로봇이 없거나 잘못된 경우
                selectedWaypointSocket[selectedRobotID] = null;
                selectedControlSocket[selectedRobotID] = null;
                selectedSpeedSocket[selectedRobotID] = null;
                selectedRemoteSocket[selectedRobotID] = null;
                console.error("No robot selected or robot ID is invalid.");
            }
        }

        // 로봇의 위치와 Waypoint를 비교하여 현재 주행 중인 Waypoint 추적 함수
        function trackRobotWaypoint(robot) {
            let closestWaypoint = null;
            let closestDistance = robotArrivedDistance;

            // 로봇이 현재 추적 중인지 확인
            let currentWaypointIndex = robotCurrentWaypoints[robot.id]
                ? selectedRobotWaypoints[robot.id].findIndex(point => point.label === robotCurrentWaypoints[robot.id])
                : 0;
            
            // 로봇이 주행 상태이면 추적
            if (robot.task !== '') {
                const currentWaypoint = selectedRobotWaypoints[robot.id][currentWaypointIndex];
                const distance = map.distance([robot.lat, robot.lng], currentWaypoint.latlng);

                // 가까운 거리 내에 있는 경우에만 추적
                if (distance <= closestDistance) {
                    closestWaypoint = currentWaypoint;
                }

                // 현재 waypoint에 도달하면 다음 waypoint로 이동
                if (closestWaypoint) {
                    if (!robotCurrentWaypoints[robot.id]) {
                        robotCurrentWaypoints[robot.id] = closestWaypoint.label;
                    }
                    else if (robotCurrentWaypoints[robot.id] === closestWaypoint.label) {
                        console.log(`Robot ${robot.id} reached waypoint: ${closestWaypoint.label}`);
                        // 다음 waypoint로 이동
                        robotCurrentWaypoints[robot.id] = selectedRobotWaypoints[robot.id][currentWaypointIndex + 1]?.label || closestWaypoint.label;
                    }

                    // 로봇이 마지막 waypoint에 도착했다면 로봇 task, departure, destination 초기화
                    if (closestWaypoint.label === selectedRobotWaypoints[robot.id][selectedRobotWaypoints[robot.id].length - 1].label) {
                        updateRobotInfo('', '', '', robot.id);
                        robotCurrentWaypoints[robot.id] = '';

                        // 로봇의 주행 경로 초기화
                        selectedRobotWaypoints[robotID] = [];
                        
                    }
                }
            }
        }

        // 로봇의 정보를 업데이트하는 함수
        function updateRobotInfo(task, departure, destination, id) {
            const robot = robots[id];
            robot.task = task;
            robot.departure = departure;
            robot.destination = destination;
        }

        // ==================================================================
        //
        //              로봇 주행 상황 및 교착 상황 시각화 함수
        //
        // ==================================================================

        // 로봇의 주행 거리를 계산하는 함수 (로봇 현위치 ~ Waypoint End)
        function calculateRemainingDistance(robot, index) {
            let totalDistance = 0;

            // 로봇의 위치에서 주행하고자 하는 첫번째 waypoint까지의 거리 계산
            totalDistance += map.distance([robot.lat, robot.lng], selectedRobotWaypoints[robot.id][index].latlng);

            // 남은 waypoints 간의 거리 합산
            for (let i = index; i < selectedRobotWaypoints[robot.id].length - 1; i++) {
                totalDistance += map.distance(selectedRobotWaypoints[robot.id][i].latlng, selectedRobotWaypoints[robot.id][i+1].latlng);
            }
            
            return totalDistance;
        }

        // 로봇의 주행 완료에 걸리는 시간을 계산하는 함수
        function calculateRemainingTime(robot, distance) {
            // 주행 명령을 받지 않았거나, 주행 완료된 경우
            if (distance === 0) {
                return 0;
            } 
            // 주행 중 로봇의 속도가 0이 아닌 경우
            else if (robot.speed > 0) {
                return distance / robot.speed;
            }
            // 주행 중 로봇의 속도가 0인 경우
            else {
                return Infinity;
            }
        }

        // 로봇의 주행 거리 및 시간을 업데이트하는 함수
        function updateDistanceAndTime(robot) {
            // 로봇이 현재 추적 중인지 확인
            let currentWaypointIndex = robotCurrentWaypoints[robot.id]? selectedRobotWaypoints[robot.id].findIndex(point => point.label === robotCurrentWaypoints[robot.id]): 0;

            // 로봇 팝업 정보
            const distanceElement = document.getElementById(`distance-${robot.id}`);
            const speedElement = document.getElementById(`speed-${robot.id}`);
            const timeElement = document.getElementById(`time-${robot.id}`);
            
            // 로봇에 주행 경로가 입력된 경우에만 실행 + 로봇이 주행 중인 경우
            if (selectedRobotWaypoints[robot.id] && robot.task !== '') {
                // 로봇의 남은 주행 거리 계산
                let remainingDistance = calculateRemainingDistance(robot, currentWaypointIndex);

                // 로봇의 남은 주행 시간 계산 (주행 거리에서 오차 범위 제거)
                let remainingTime = calculateRemainingTime(robot, remainingDistance - robotArrivedDistance);

                // 로봇 팝업 정보 업데이트
                distanceElement.textContent = remainingDistance.toFixed(2);
                speedElement.textContent = robot.speed.toFixed(2);
                timeElement.textContent = remainingTime.toFixed(2);

                // console.log(`[Robot ${robot.id}] Remaining Distance: ${remainingDistance} meters`);
                // console.log(`[Robot ${robot.id}] Remaining Time: ${remainingTime} seconds`);
            }
        }

        // 오른쪽 사이드바 열기/닫기 토글 함수
        function toggleSidebarRight() {
            const sidebarRight = document.getElementById('sidebar-right');
            sidebarRight.classList.toggle('open');
        }

        // 왼쪽 사이드바 열기/닫기 토글 함수
        function toggleSidebarLeft() {
            const sidebarLeft = document.getElementById('sidebar-left');
            sidebarLeft.classList.toggle('open');
        }
        
        // 로봇 팝업창을 생성하는 함수
        function addRobotInfoPopup(id) {
            const robotInfoContainer = document.getElementById('robotInfoContainer');

            // 팝업창 생성
            const robotInfoPopup = document.createElement('div');
            robotInfoPopup.classList.add('popup');
            robotInfoPopup.id = `popup-${id}`;
            robotInfoPopup.innerHTML = `
                <h4>로봇 ${id} 정보</h4>
                <div class="info">
                    <p><strong>남은 거리:</strong> <span id="distance-${id}">0</span> m</p>
                    <p><strong>로봇 속도:</strong> <span id="speed-${id}">0</span> m/s</p>
                    <p><strong>남은 시간:</strong> <span id="time-${id}">0</span> sec</p>
                </div>
            `;

            // 팝업창을 컨테이너에 추가
            robotInfoContainer.appendChild(robotInfoPopup);
        }

        // 교착 확률에 따른 클래스 지정 함수
        function getProbabilityClass(probability) {
            if (probability < 0.33) return 'low-probability';
            if (probability < 0.66) return 'medium-probability';
            return 'high-probability';
        }

        // 행렬 생성 함수
        function initializeMatrix() {
            const robotCount = Object.keys(robots).length;
            matrixContainer.style.gridTemplateColumns = `repeat(${robotCount + 1}, 3vh)`;
            matrixContainer.innerHTML = ''; // 행렬 초기화

            // 첫 번째 행 라벨 추가
            const headerCell = document.createElement('div');
            headerCell.classList.add('matrix-cell', 'label-init-cell');
            matrixContainer.appendChild(headerCell); // 빈 셀

            for (let i = 0; i < robotCount; i++) {
                const labelCell = document.createElement('div');
                labelCell.classList.add('matrix-cell', 'label-cell');
                labelCell.textContent = `Robot ${i + 1}`; // 라벨 추가
                matrixContainer.appendChild(labelCell);
            }

            for (let i = 0; i < robotCount; i++) {
                // 각 로봇의 라벨 추가
                const labelCell = document.createElement('div');
                labelCell.classList.add('matrix-cell', 'label-cell');
                labelCell.textContent = `Robot ${i + 1}`; // 라벨 추가
                matrixContainer.appendChild(labelCell);
                for (let j = 0; j < robotCount; j++) {
                    if (i === j) {
                        // 동일 로봇 간에는 교착 확률을 표시 X
                        const emptyCell = document.createElement('div');
                        emptyCell.classList.add('matrix-cell');
                        matrixContainer.appendChild(emptyCell);
                        continue;
                    }
                    const cell = document.createElement('div');
                    cell.id = `prob-${i}-${j}`;
                    cell.classList.add('matrix-cell');
                    matrixContainer.appendChild(cell);
                }
            }
        }

        // 행렬 업데이트 함수
        function updateMatrix() {
            const robotCount = Object.keys(robots).length;
            for (let i = 0; i < robotCount; i++) {
                for (let j = 0; j < robotCount; j++) {
                    // 스스로와의 교착 확률은 계산하지 않음
                    if (i === j) continue;

                    // 주행 명령을 받지 않은 로봇과의 교착 확률은 계산하지 않음
                    if (!selectedRobotWaypoints[i + 1] || !selectedRobotWaypoints[j + 1]) continue;
                    const cell = document.getElementById(`prob-${i}-${j}`);
                    let probability = 0.0;
                    let sectionNum = 0;
                    
                    // 혼합 ID 생성
                    const mixID = generateMixID(robots[i + 1].id, robots[j + 1].id);

                    // 교착 확률 및 교착 지점 업데이트
                    ({ P_deadlock: probability, deadlockSectionNum: sectionNum } = calculateDeadlockProbability(robots[i + 1], robots[j + 1], selectedRobotWaypoints[i + 1], selectedRobotWaypoints[j + 1]), mixID);

                    // 셀 업데이트
                    cell.textContent = (probability * 100).toFixed(1) + '%';
                    cell.className = getProbabilityClass(probability);

                    // 교착 확률이 0.5(50%)가 넘는 경우 로봇 우선순위 세팅 함수 실행
                    if (probability > 0.5) {
                        setPriority(robots[i + 1], robots[j + 1], selectedRobotWaypoints[i + 1], selectedRobotWaypoints[j + 1], sectionNum, mixID);
                    }

                    if (deadlockSolveFlag[mixID]) {
                        resolveDeadlock(selectedRobotWaypoints[i + 1], selectedRobotWaypoints[j + 1], sectionNum, mixID);
                    }
                }
            }
        }

        // 교착 확률 행렬 확대 함수
        function zoomIn() {
            scale += zoomStep;
            updateMatrixScale();
        }

        // 교착 확률 행렬 축소 함수
        function zoomOut() {
            scale = Math.max(0.5, scale - zoomStep); // 최소 스케일 제한
            updateMatrixScale();
        }

        // 행렬 스케일 업데이트 함수
        function updateMatrixScale() {
            const matrixContainer = document.getElementById('probabilityMatrix');

            // 행렬 스케일 조정
            matrixContainer.style.transform = `scale(${scale})`;

            // 행렬의 확대/축소에 맞게 Wrapper에서 스크롤 가능하도록 설정
            const wrapper = document.getElementById('matrixContainerWrapper');
            wrapper.style.overflow = 'auto';
        }

        // ==================================================================
        //
        //              교착 상황 파악 및 해결 함수 (확률 기반 제어)
        //
        // ==================================================================

        // 교착 확률 수치화 모델 (거리 기반 동적 모델)
        function calculateDeadlockProbability(robot1, robot2, waypoints1, waypoints2, mixID) {

            let P_c = 0.0;              // 경로 교차 지점 기반 확률
            let P_d = 0.0;              // 거리 기반 확률
            let P_deadlock = 0.0;       // 최종 교착 확률
            let P_d_temp = [];          // 각 교착 지점의 거리 기반 확률
            let P_deadlock_temp = [];   // 각 교착 지점의 교착 확률
            let deadlockSectionNum = 0; // 교착 확률이 높은 지점의 번호
            let zero_count = 0;         // 교착 확률이 0인 지점을 카운트
            let drivingDirection = 0;   // 교착 지점에서의 주행 방향 관계

            // 경로 교차 지점 탐색
            const intersectionPoints = findIntersectionPoint(waypoints1, waypoints2);

            // 경로 교차 지점 존재 시 확률 계산
            if (intersectionPoints && intersectionPoints.length >= 1) {
                const overlapSegmentNum = intersectionPoints.length;

                for (let i = 0; i < overlapSegmentNum; i++) {
                    // 경로 교착 지점 기반 확률
                    ({ P_c: P_c, drivingDirection: drivingDirection } = calculateSegmentCrossingProbability(robot1, robot2, intersectionPoints[i]));

                    // 거리 기반 확률
                    const overlapWaypointNum = intersectionPoints[i].length;
                    const overlapDistance = calculateOverlappingSegmentDistance(intersectionPoints[i])
                    const D_min = drivingDirection * overlapDistance;

                    const robot1OverlapStartIndex = findIntersectionStartAndEnd(robot1, intersectionPoints[i], overlapWaypointNum, 'Start')
                    const robot1OverlapEndIndex = findIntersectionStartAndEnd(robot1, intersectionPoints[i], overlapWaypointNum, 'End')
                    const robot2OverlapStartIndex = findIntersectionStartAndEnd(robot2, intersectionPoints[i], overlapWaypointNum, 'Start')
                    const robot2OverlapEndIndex = findIntersectionStartAndEnd(robot2, intersectionPoints[i], overlapWaypointNum, 'End')
                    const robot1CurrentIndex = findRobotWaypointIndex(robot1, robotCurrentWaypoints[robot1.id], 'label');
                    const robot2CurrentIndex = findRobotWaypointIndex(robot2, robotCurrentWaypoints[robot2.id], 'label');

                    let distance = 0;

                    const robot1ToOverlapStart = calculateRemainingDistanceToPoint(robot1, robot1OverlapStartIndex);
                    const robot2ToOverlapStart = calculateRemainingDistanceToPoint(robot2, robot2OverlapStartIndex);
                    const robot1ToOverlapEnd = calculateRemainingDistanceToPoint(robot1, robot1OverlapEndIndex);
                    const robot2ToOverlapEnd = calculateRemainingDistanceToPoint(robot2, robot2OverlapEndIndex);

                    if (drivingDirection === 2) {
                        if (robot1CurrentIndex < robot1OverlapStartIndex && robot2CurrentIndex < robot2OverlapStartIndex) {
                            distance = robot1ToOverlapStart + overlapDistance + robot2ToOverlapStart;
                        }
                        else if (robot1CurrentIndex >= robot1OverlapStartIndex && robot2CurrentIndex < robot2OverlapStartIndex) {
                            distance = robot1ToOverlapEnd + robot2ToOverlapStart;
                        }
                        else if (robot1CurrentIndex < robot1OverlapStartIndex && robot2CurrentIndex >= robot2OverlapStartIndex) {
                            distance = robot1ToOverlapStart + robot2ToOverlapEnd;
                        }
                    }
                    else if (drivingDirection === 1) {
                        if (robot1CurrentIndex <= robot1OverlapStartIndex && robot2CurrentIndex <= robot2OverlapStartIndex) {
                            distance = robot1ToOverlapStart + robot2ToOverlapStart;
                        }
                        else if (robot1CurrentIndex > robot1OverlapStartIndex && robot2CurrentIndex <= robot2OverlapStartIndex) {
                            distance = robot2ToOverlapStart - robot1ToOverlapStart;
                        }
                        else if (robot1CurrentIndex <= robot1OverlapStartIndex && robot2CurrentIndex > robot2OverlapStartIndex) {
                            distance = robot1ToOverlapStart - robot2ToOverlapStart;
                        }
                    }

                    // 다양한 이유로 교착 지점에 로봇이 정지해서 속도(시간을 계산)에 기반을 한 교착 지점 기반 확률이 정상적으로 계산되지 않은 경우
                    // ex. 장애물 조우, 비상정지, 교착 상황 회피를 위한 정지 등
                    if (robot1ToOverlapStart <= 0 && robot2ToOverlapStart > 0) {
                        if (robot1.speed < 0.01) {
                            P_c = 1;
                        }
                    }
                    else if (robot1ToOverlapStart > 0 && robot2ToOverlapStart <= 0) {
                        if (robot2.speed < 0.01) {
                            P_c = 1;
                        }
                    }

                    P_d = 1 / (1 + Math.exp(2 * (distance - D_min)));
                    // console.log(`Robot ${robot1.id} and Robot ${robot2.id} [direction]: ${drivingDirection}, [distance]: ${distance}, [P_d]: ${P_d}`);
                    P_d_temp[i] = P_d;
                    P_deadlock_temp[i] = P_d * P_c;
                    // console.log(`Robot ${robot1.id} Section ${i} Deadlock Prob: ${P_deadlock_temp[i]} and Distance Prob: ${P_d_temp[i]}`);
                }
                
                // 각 교착 지점 중 임계 확률 이상인 지점 탐색
                for (let i = 0; i < overlapSegmentNum; i++) {
                    if (P_deadlock_temp[i] > 0.5) {
                        P_deadlock = P_deadlock_temp[i];
                        deadlockSectionNum = i;
                    }
                    else if (P_deadlock_temp[i] < 0.1 || isNaN(P_deadlock_temp[i])) {
                        zero_count += 1;
                    }
                }

                // 각 교착 지점에서의 교착 확률이 모두 0인 경우에는 거리 기반 확률로 판단
                if (zero_count === overlapSegmentNum) {
                    for (let i = 0; i < overlapSegmentNum; i++) {
                        if (P_d_temp[i] > 0.9) {
                            P_deadlock = 0.0;
                            deadlockSectionNum = i;
                        }
                    }
                }
            }

            return { P_deadlock, deadlockSectionNum };
        }

        // 교착 지점 탐지 함수
        function findIntersectionPoint(waypoints1, waypoints2) {
            const overlappingSegments = [];
            let tempSegment = [];
            
            for (let i = 0; i < waypoints1.length; i++) {
                for (let j = 0; j < waypoints2.length; j++) {

                    // 경로 상 waypoint 중 일치하는 지점이 있는 지 확인
                    if (waypoints1[i].latlng.lat === waypoints2[j].latlng.lat && waypoints1[i].latlng.lng === waypoints2[j].latlng.lng) {
                        // waypoint가 일치 시에는 임시 배열에 저장 
                        tempSegment.push({ lat: waypoints1[i].latlng.lat, lng: waypoints1[i].latlng.lng });

                        if (i < waypoints1.length - 1) {
                            // 해당 waypoint의 다음 waypoint도 겹치는 지 확인
                            if (j === 0) {
                                if (waypoints1[i + 1].latlng.lat !== waypoints2[j + 1].latlng.lat && waypoints1[i + 1].latlng.lng !== waypoints2[j + 1].latlng.lng) {
                                    // 겹친 경로 저장
                                    if (tempSegment.length > 0) {
                                        overlappingSegments.push([...tempSegment]);
                                    }
            
                                    tempSegment = [];   // 임시 배열 초기화
                                }
                            }
                            else if (j > 0) {
                                if ((waypoints1[i + 1].latlng.lat !== waypoints2[j + 1].latlng.lat && waypoints1[i + 1].latlng.lng !== waypoints2[j + 1].latlng.lng) &&
                                    (waypoints1[i + 1].latlng.lat !== waypoints2[j - 1].latlng.lat && waypoints1[i + 1].latlng.lng !== waypoints2[j - 1].latlng.lng)) {
                                    
                                    // 겹친 경로 저장
                                    if (tempSegment.length > 0) {
                                        overlappingSegments.push([...tempSegment]);
                                    }
            
                                    tempSegment = [];   // 임시 배열 초기화
                                }
                            }
                            else if (j === waypoints2.length - 1) {
                                if (waypoints1[i + 1].latlng.lat !== waypoints2[j - 1].latlng.lat && waypoints1[i + 1].latlng.lng !== waypoints2[j - 1].latlng.lng) {
                                    // 겹친 경로 저장
                                    if (tempSegment.length > 0) {
                                        overlappingSegments.push([...tempSegment]);
                                    }
            
                                    tempSegment = [];   // 임시 배열 초기화
                                }
                            }
                        }
                        else {
                            // waypoint가 끝났을 경우 겹친 경로 존재 시에 저장
                            if (tempSegment.length > 0) {
                                overlappingSegments.push([...tempSegment]);
                            }
                        }
                    }
                }
            }

            return overlappingSegments.length > 0 ? overlappingSegments : null;
        }

        // 겹친 경로에서 로봇의 교착 확률 계산 함수
        function calculateSegmentCrossingProbability(robot1, robot2, overlapSegment) {
            const startPoint = overlapSegment[0];
            const endPoint = overlapSegment[overlapSegment.length - 1];

            const pointIndex1_1 = findRobotWaypointIndex(robot1, startPoint, 'point');
            const pointIndex1_2 = findRobotWaypointIndex(robot1, endPoint, 'point');
            const pointIndex2_1 = findRobotWaypointIndex(robot2, startPoint, 'point');
            const pointIndex2_2 = findRobotWaypointIndex(robot2, endPoint, 'point');

            // 기준 로봇과 상대방 로봇의 주행 방향 관계
            // 정방향 = 1 / 역방향 = 2
            let drivingDirection = 2
            
            // 겹친 경로에서 상대방 로봇의 주행 방향이 기준이 되는 로봇과 일치하는 지 판단 
            if (pointIndex2_1 < pointIndex2_2) {    
                drivingDirection = 1;
            }

            // 교차지점을 이미 지나친 경우 교차 확률은 0
            if (drivingDirection === 2) {
                // 역방향일 경우
                if (checkPassIntersection(robot1, pointIndex1_2) || checkPassIntersection(robot2, pointIndex2_1)) {
                    return 0;
                }
            }
            else if (drivingDirection === 1) {
                // 정방향일 경우
                if (checkPassIntersection(robot1, pointIndex1_2) || checkPassIntersection(robot2, pointIndex2_2)) {
                    return 0;
                }
            }
        
            // 각 로봇의 waypoint 사이 남은 거리 계산
            const distanceToIntersection1 = calculateRemainingDistanceToPoint(robot1, pointIndex1_2);
            // 상대방 로봇의 경우 주행 방향에 따라 다르게 계산
            let distanceToIntersection2 = 0.0;
            if (drivingDirection === 2)      { distanceToIntersection2 = calculateRemainingDistanceToPoint(robot2, pointIndex2_1); }  // 역방향
            else if (drivingDirection === 1) { distanceToIntersection2 = calculateRemainingDistanceToPoint(robot2, pointIndex2_2); }  // 정방향
        
            // 두 로봇이 각 waypoint 사이를 이동하는 시간 계산
            const timeToIntersection1 = Math.abs(calculateRemainingTime(robot1, distanceToIntersection1));
            const timeToIntersection2 = Math.abs(calculateRemainingTime(robot2, distanceToIntersection2));
        
            // 두 로봇이 만날 확률을 구간 내에서 수치화
            const distanceDifference = Math.abs(distanceToIntersection1 - distanceToIntersection2);
            const timeDifference = Math.abs(timeToIntersection1 - timeToIntersection2);
            
            // 거리 차이와 시간 차이를 종합적으로 고려하여 만날 확률을 계산
            // 설정 기준: waypoint 간의 간격 및 기존 속도로 주행 시 소요 시간
            const proximityThreshold = calculateOverlappingSegmentDistance(overlapSegment)      // 두 로봇이 가까워질 때의 임계 거리 (단위: m)
            const timeThreshold = proximityThreshold / maxRobotSpeed;                           // 두 로봇의 시간 차이 임계값 (초)
        
            const distanceFactor = 1 / (1 + Math.exp(0.2 * (distanceDifference - proximityThreshold)));
            const timeFactor = 1 / (1 + Math.exp(1.0 * (timeDifference - timeThreshold)));
        
            // 최종 교차 확률은 거리와 시간의 조합으로 결정
            const P_c = distanceFactor * timeFactor;

            return { P_c , drivingDirection };
        }        

        // 좌표 또는 라벨과 일치하는 waypoint index 탐색 함수
        function findRobotWaypointIndex(robot, targetPointInfo, type) {
            let targetIndex = 0;

            if (type === 'point') {
                for (let i = 0; i < selectedRobotWaypoints[robot.id].length; i++) {
                    const point = selectedRobotWaypoints[robot.id][i];
                    
                    // waypoint 좌표 일치 시에 index 저장
                    if (point.latlng.lat === targetPointInfo.lat && point.latlng.lng === targetPointInfo.lng) {
                        targetIndex = i;
                    }
                }
            }
            else if (type === 'label') {
                for (let i = 0; i < selectedRobotWaypoints[robot.id].length; i++) {
                    const point = selectedRobotWaypoints[robot.id][i];
                    
                    // waypoint 라벨 일치 시에 index 저장
                    if (point.label === targetPointInfo) {
                        targetIndex = i;
                    }
                }
            }

            return targetIndex;
        }

        // 로봇이 겹친 경로를 지났는 지 확인하는 함수
        function checkPassIntersection(robot, targetIndex) {
            let currentWaypointIndex = robotCurrentWaypoints[robot.id]
                ? selectedRobotWaypoints[robot.id].findIndex(point => point.label === robotCurrentWaypoints[robot.id])
                : 0;

            return currentWaypointIndex > targetIndex;
        }

        // 목표 Waypoint로부터 로봇의 주행 거리를 계산하는 함수 (로봇 현위치 ~ Target Waypoint)
        function calculateRemainingDistanceToPoint(robot, index) {
            let totalDistance = 0;

            let currentWaypointIndex = robotCurrentWaypoints[robot.id]
                ? selectedRobotWaypoints[robot.id].findIndex(point => point.label === robotCurrentWaypoints[robot.id])
                : 0;

            // Case 1: 로봇의 현위치 index가 목표 waypoint index와 같을 경우
            // 로봇의 현위치로부터 목표 waypoint까지의 거리
            if (currentWaypointIndex === index) {
                totalDistance = map.distance([robot.lat, robot.lng], selectedRobotWaypoints[robot.id][currentWaypointIndex].latlng);
            }

            // Case 2: 로봇의 현위치 index가 목표 waypoint index보다 작을 경우
            // 로봇의 현위치로부터 목표 waypoint까지의 거리 + 목표 Waypoint까지의 남은 waypoint 간의 거리
            if (currentWaypointIndex < index) {
                // 로봇의 현위치로부터 목표 waypoint까지의 거리 합산
                totalDistance += map.distance([robot.lat, robot.lng], selectedRobotWaypoints[robot.id][currentWaypointIndex].latlng);
                // 목표 Waypoint까지의 남은 waypoint 간의 거리 합산
                for (let i = currentWaypointIndex; i < index; i++) {
                    totalDistance += map.distance(selectedRobotWaypoints[robot.id][i].latlng, selectedRobotWaypoints[robot.id][i + 1].latlng);
                }
            }

            // Case 3: 로봇의 현위치 index가 목표 waypoint index보다 클 경우
            // 로봇의 현위치로부터 목표 waypoint까지의 거리 차감
            if (currentWaypointIndex > index) {
                totalDistance -= map.distance(selectedRobotWaypoints[robot.id][index].latlng, [robot.lat, robot.lng]);
            }

            // console.log(`Robot ${robot.id}: Total Distance to Waypoint ${selectedRobotWaypoints[robot.id][index].label} is ${totalDistance} meter.`);
            
            return totalDistance;
        }

        // 겹친 경로의 주행 거리를 계산하는 함수
        function calculateOverlappingSegmentDistance(overlapSegment) {
            let totalDistance = 0;

            for (let i = 0; i < overlapSegment.length - 1; i++) {
                totalDistance += map.distance([overlapSegment[i].lat, overlapSegment[i].lng], [overlapSegment[i + 1].lat, overlapSegment[i + 1].lng]);
            }

            return totalDistance;
        }

        // 로봇 우선순위 세팅 함수 (교착 상황)
        function setPriority(robot1, robot2, waypoints1, waypoints2, sectionNum, mixID) {

            // 경로 교차 지점 탐색
            const intersectionPoints = findIntersectionPoint(waypoints1, waypoints2);
            const overlapWaypointNum = intersectionPoints[sectionNum].length; 

            const robot1OverlapStartIndex = findIntersectionStartAndEnd(robot1, intersectionPoints[sectionNum], overlapWaypointNum, 'Start');
            const robot2OverlapStartIndex = findIntersectionStartAndEnd(robot2, intersectionPoints[sectionNum], overlapWaypointNum, 'Start');

            // 겹친 경로까지의 거리 계산
            const robot1ToOverlapStart = calculateRemainingDistanceToPoint(robot1, robot1OverlapStartIndex);
            const robot2ToOverlapStart = calculateRemainingDistanceToPoint(robot2, robot2OverlapStartIndex);

            // 겹친 경로까지의 거리를 비교하여 우선순위 판단
            if (robot1ToOverlapStart > robot2ToOverlapStart) {
                robot1.priority = 'low';
                robot2.priority = 'high';
            }
            else if (robot1ToOverlapStart < robot2ToOverlapStart) {
                robot1.priority = 'high';
                robot2.priority = 'low';
            }

            // 교착 상태 우선순위 객체 추가
            if (!deadlockPriority[mixID]) {
                deadlockPriority[mixID] = { highRobot: [], lowRobot: [] };
            }

             // 교착 상태 우선순위 객체에 높은 로봇과 낮은 로봇 저장
            deadlockPriority[mixID] = {
                highRobot: robot1.priority === 'high' ? robot1 : robot2,
                lowRobot: robot1.priority === 'low' ? robot1 : robot2
            };

            console.log(`High robot is [Robot ${deadlockPriority[mixID].highRobot.id}] and Low robot is [Robot ${deadlockPriority[mixID].lowRobot.id}]`);

            // 교착 상태 해결 플래그 추가
            if (!deadlockSolveFlag[mixID]) {
                deadlockSolveFlag[mixID] = { solveFlag: true, stopFlag: false, redriveFlag: false };
            }
        }

        // 교착 상황 해결 함수
        function resolveDeadlock(waypoints1, waypoints2, sectionNum, mixID) {
            // 우선순위 높은 로봇 및 낮은 로봇
            const highRobot = deadlockPriority[mixID].highRobot;
            const lowRobot = deadlockPriority[mixID].lowRobot;

            // 경로 교차 지점 탐색
            const intersectionPoints = findIntersectionPoint(waypoints1, waypoints2);
            const overlapWaypointNum = intersectionPoints[sectionNum].length;

            const highRobotOverlapStartIndex = findIntersectionStartAndEnd(highRobot, intersectionPoints[sectionNum], overlapWaypointNum, 'Start');
            const lowRobotOverlapStartIndex = findIntersectionStartAndEnd(lowRobot, intersectionPoints[sectionNum], overlapWaypointNum, 'Start');
            const highRobotOverlapEndIndex = findIntersectionStartAndEnd(highRobot, intersectionPoints[sectionNum], overlapWaypointNum, 'End');
            const lowRobotOverlapEndIndex = findIntersectionStartAndEnd(lowRobot, intersectionPoints[sectionNum], overlapWaypointNum, 'End');

            // 겹친 경로까지의 거리 계산
            const highRobotToOverlapStart = calculateRemainingDistanceToPoint(highRobot, highRobotOverlapStartIndex);
            const lowRobotToOverlapStart = calculateRemainingDistanceToPoint(lowRobot, lowRobotOverlapStartIndex);
            
            // 교착 상태 해결에 필요한 current index를 탐색
            const highRobotCurrentIndex = findRobotWaypointIndex(highRobot, robotCurrentWaypoints[highRobot.id], 'label');
            const lowRobotCurrentIndex = findRobotWaypointIndex(lowRobot, robotCurrentWaypoints[lowRobot.id], 'label');

            console.log(`Robot ${highRobot.id} Current Index: ${highRobotCurrentIndex} / End Index: ${highRobotOverlapEndIndex}`);

            // 1. 우선순위 낮은 로봇이 겹친 경로로부터 1m 떨어진 위치에 도착 시 정지 명령 전달
            if (!deadlockSolveFlag[mixID].stopFlag) {
                console.log(`[High] Robot ${highRobot.id}: ${highRobotToOverlapStart} / [Low] Robot ${lowRobot.id}: ${lowRobotToOverlapStart}`);
                if (lowRobotToOverlapStart <= 2.0) {
                    updateRobotSpeed(0.00, lowRobot.id);
                    deadlockSolveFlag[mixID].stopFlag = true;
                }
            }
            // 2. 우선순위 높은 로봇이 겹친 경로를 주행 완료 시 우선순위 낮은 로봇에게 주행 재개 명령 전달
            else if (deadlockSolveFlag[mixID].stopFlag && !deadlockSolveFlag[mixID].redriveFlag) {
                if (highRobotCurrentIndex > highRobotOverlapEndIndex) {
                    console.log(`Robot ${highRobot.id} Current Index: ${highRobotCurrentIndex} / End Index: ${highRobotOverlapEndIndex}`);
                    updateRobotSpeed(maxRobotSpeed, lowRobot.id);
                    deadlockSolveFlag[mixID].redriveFlag = true;
                }
            }
            else if (deadlockSolveFlag[mixID].redriveFlag) {
                // 우선순위 및 플래그 삭제
                delete deadlockPriority[mixID];
                delete deadlockSolveFlag[mixID];
            }
        }

        // 로봇마다 겹친 경로의 시작과 끝 index를 탐색해주는 함수
        function findIntersectionStartAndEnd(robot, intersectionPoints, length, seq) {
            // 처음 point와 마지막 point의 index 탐색
            const firstPointIndex = findRobotWaypointIndex(robot, intersectionPoints[0], 'point');
            const lastPointIndex = findRobotWaypointIndex(robot, intersectionPoints[length - 1], 'point');

            // 원하는 순서의 index 반환
            if (seq === 'Start') {
                return firstPointIndex < lastPointIndex? firstPointIndex : lastPointIndex;
            }
            else if (seq === 'End') {
                return firstPointIndex > lastPointIndex? firstPointIndex : lastPointIndex;
            }
        } 
        
        // 혼합 ID 생성 함수(교착 상황을 케이스 별로 구분하는 용도)
        function generateMixID(id1, id2) {
            const ids = [id1, id2].sort();
            return `${ids[0]}_${ids[1]}`;
        }

         // DB Robot 팝업 열기 및 데이터 조회 함수
         async function openDBRobotPopup() {
            await fetchRobotList(); // 로봇 목록 조회 후 팝업 열기
            document.getElementById("dbRobotPopup").style.display = "block"; // 팝업 표시
        }

        // DB Robot 팝업 닫기 함수
        function closeDBRobotPopup() {
            document.getElementById("dbRobotPopup").style.display = "none"; // 팝업 숨기기
        }

        // 첫 번째 팝업에서 로봇 목록을 클릭하면 Path 목록을 표시하는 팝업을 띄움
        async function fetchRobotList() {
            try {
                const { data: robots, error } = await supabase.from('Robot').select('id, robotId, name').order('id', { ascending: true });
                if (error) {
                    console.error('로봇 목록 조회 오류:', error);
                    return;
                }

                const robotListDiv = document.getElementById("robotListDisplay");
                robotListDiv.innerHTML = ""; // 기존 내용을 지우기

                robots.forEach(robot => {
                    const robotItem = document.createElement("div");
                    robotItem.style = "padding: 10px; background-color: #f8f9fa; border: 1px solid #ddd; border-radius: 5px; margin-bottom: 5px; cursor: pointer;";
                    robotItem.innerHTML = `<strong>ID:</strong> ${robot.id}, <strong>로봇 ID:</strong> ${robot.robotId}, <strong>이름:</strong> ${robot.name}`;

                    // 로봇을 클릭하면 Path 목록을 표시하는 함수 호출
                    robotItem.onclick = () => {
                        closeDBRobotPopup();  // 첫 번째 팝업 닫기
                        openPathListPopup(robot.id);  // 두 번째 팝업 열기
                    };

                    robotListDiv.appendChild(robotItem);
                });

        

            } catch (error) {
                console.error("Unexpected error:", error);
            }
        }

        // 새로운 로봇 데이터를 추가할 수 있는 폼을 표시하는 함수
        function openAddRobotPopup() {
            const popupContainer = document.createElement('div');
            popupContainer.id = 'newRobotPopup';  // ID 추가
            popupContainer.style = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 90%;
                max-width: 300px;
                padding: 20px;
                background-color: #ffffff;
                border-radius: 8px;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
                font-size: 14px;
                z-index: 1000;
            `;

            popupContainer.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3 style="margin: 0; font-size: 18px;">Add New Robot</h3>
                    <button onclick="closeAddRobotPopup()" style="background: none; border: none; font-size: 20px; font-weight: bold; cursor: pointer;">&times;</button>
                </div>
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    <label>Robot ID:</label>
                    <input type="text" id="newRobotId" placeholder="Enter Robot ID" style="padding: 8px; border: 1px solid #ddd; border-radius: 5px; font-size: 14px;"/>
                    
                    <label>Name:</label>
                    <input type="text" id="newRobotName" placeholder="Enter Robot Name" style="padding: 8px; border: 1px solid #ddd; border-radius: 5px; font-size: 14px;"/>
                </div>
                <div style="display: flex; justify-content: space-between; margin-top: 15px;">
                    <button onclick="addNewRobot()" style="width: 48%; padding: 10px; font-size: 16px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">Save</button>
                    <button onclick="closeAddRobotPopup()" style="width: 48%; padding: 10px; font-size: 16px; background-color: #f8f9fa; color: black; border: 1px solid #ddd; border-radius: 5px; cursor: pointer;">Cancel</button>
                </div>
            `;

            document.body.appendChild(popupContainer);
        }

        // 팝업을 닫는 함수
        function closeAddRobotPopup() {
            const popupContainer = document.querySelector('#newRobotPopup');
            if (popupContainer) {
                document.body.removeChild(popupContainer);
            }
        }


        // 새로운 로봇 데이터를 Supabase DB에 추가하는 함수
        async function addNewRobot() {
            const robotId = document.getElementById("newRobotId").value;
            const name = document.getElementById("newRobotName").value;

            if (!robotId || !name) {
                alert("Robot ID와 Name을 모두 입력하세요.");
                return;
            }

            // DB에 robotId, name, siteId(1)로만 데이터 삽입
            const { error } = await supabase.from('Robot').insert([
                { robotId, name, siteId: 1 }  // ID는 자동 생성됨
            ]);

            if (error) {
                console.error("로봇 추가 오류:", error);
                alert("로봇 추가에 실패했습니다.");
            } else {
                alert("새로운 로봇이 추가되었습니다.");
                closeAddRobotPopup();  // 팝업 닫기
                fetchRobotList();  // 로봇 목록 갱신
            }
        }

        

        // Path 목록을 표시하는 함수 (로봇 ID를 인자로 받음)
        async function openPathListPopup(robotId) {
            selected_RobotId = robotId;
            const pathListDisplay = document.getElementById("pathListDisplay");
            pathListDisplay.innerHTML = ""; // 기존 목록 초기화

            try {
                const { data: paths, error } = await supabase
                    .from('Path')
                    .select('id, name')
                    .eq('robotId', robotId) // 로봇 ID에 해당하는 Path만 조회
                    .order('name', { ascending: true });

                if (error) {
                    console.error('Path 목록 조회 오류:', error);
                    return;
                }

                paths.forEach(path => {
                    const pathItem = document.createElement("div");
                    pathItem.style = "padding: 10px; background-color: #e0f7fa; border: 1px solid #00796b; border-radius: 5px; margin-bottom: 5px; cursor: pointer;";
                    pathItem.innerHTML = `<strong>Path Name:</strong> ${path.name}
                    <button onclick="enableAddWaypointMode(${path.id})" style="float: right; background: none; border: none; font-size: 14px; color: #007bff; cursor: pointer; margin-left: 10px;">+Add Waypoint</button>
                    `;

                    // Path를 클릭하면 Path ID를 저장하고 팝업을 닫음
                    pathItem.onclick = () => {
                        selectedPathId = path.id; // 선택된 Path ID 저장
                        closePathListPopup();  // 두 번째 팝업 닫기
                        showWaypointsForPath(path.id);
                    };

                    pathListDisplay.appendChild(pathItem);
                });

                document.getElementById("pathListPopup").style.display = "block"; // 팝업 열기

                
            } catch (error) {
                console.error("Path 목록 불러오기 오류:", error);
            }
        }

        // 새로운 Path를 추가할 수 있는 폼을 표시하는 함수
        function openAddPathPopup() {
            const addPathPopup = document.createElement('div');
            addPathPopup.id = 'newPathPopup';  // ID를 추가하여 팝업 닫기 함수에서 찾을 수 있도록 설정
            addPathPopup.style = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 90%;
                max-width: 300px;
                padding: 20px;
                background-color: #ffffff;
                border-radius: 8px;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
                font-size: 14px;
                z-index: 1000;
            `;

            addPathPopup.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3 style="margin: 0; font-size: 18px;">Add New Path</h3>
                    <button onclick="closeAddPathPopup()" style="background: none; border: none; font-size: 20px; font-weight: bold; cursor: pointer;">&times;</button>
                </div>
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    <label>Description:</label>
                    <input type="text" id="newPathDescription" placeholder="Enter Description" style="padding: 8px; border: 1px solid #ddd; border-radius: 5px; font-size: 14px;"/>
                    
                    <label>Type:</label>
                    <input type="text" id="newPathType" placeholder="Enter Type" style="padding: 8px; border: 1px solid #ddd; border-radius: 5px; font-size: 14px;"/>
                </div>
                <div style="display: flex; justify-content: space-between; margin-top: 15px;">
                    <button onclick="addNewPath()" style="width: 48%; padding: 10px; font-size: 16px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">Save</button>
                    <button onclick="closeAddPathPopup()" style="width: 48%; padding: 10px; font-size: 16px; background-color: #f8f9fa; color: black; border: 1px solid #ddd; border-radius: 5px; cursor: pointer;">Cancel</button>
                </div>
            `;

            document.body.appendChild(addPathPopup);
        }

        // 새로운 Path 데이터를 Supabase DB에 추가하는 함수
        async function addNewPath() {
            const description = document.getElementById("newPathDescription").value;
            const type = document.getElementById("newPathType").value;

            if (!description || !type) {
                alert("Description과 Type을 모두 입력하세요.");
                return;
            }

            const { error } = await supabase.from('Path').insert([{ 
                robotId: selectedRobotId, 
                name: "New Path", 
                description: description, 
                color: "gray", 
                type: type 
            }]);

            if (error) {
                console.error("Path 추가 오류:", error);
                alert("Path 추가에 실패했습니다.");
            } else {
                alert("새로운 Path가 추가되었습니다.");
                closeAddPathPopup();
                loadPathList(selectedRobotId); // Path 목록 갱신
            }
        }

        // Path 추가 팝업 닫기 함수
        function closeAddPathPopup() {
            const addPathPopup = document.querySelector('#newPathPopup');
            if (addPathPopup) {
                document.body.removeChild(addPathPopup);
            }
        }

        
        // 첫 번째 팝업 닫기 함수
        function closeDBRobotPopup() {
            document.getElementById("dbRobotPopup").style.display = "none"; // 첫 번째 팝업 숨기기
        }

        // 두 번째 팝업 닫기 함수
        function closePathListPopup() {
            document.getElementById("pathListPopup").style.display = "none"; // 두 번째 팝업 숨기기
        }

        // WebSocket 연결을 위한 전역 변수
        let socket;
        let isSocketInitialized = false; // WebSocket이 초기화되었는지 확인하는 변수

        // WebSocket 초기화 및 연결 함수
        function initializeWebSocket() {
            // WebSocket이 이미 열려 있는 경우 새로 열지 않고 함수 종료
            if (isSocketInitialized && socket.readyState === WebSocket.OPEN) {
                console.log("이미 WebSocket이 열려 있습니다.");
                return;
            }

            socket = new WebSocket('ws://192.168.0.10:8000'); // 로봇의 IP 주소와 포트를 설정하세요.

            socket.onopen = () => {
                console.log("WebSocket 연결 성공");
                isSocketInitialized = true; // WebSocket 초기화 완료 표시
            };

            socket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                console.log("Received from WebSocket:", data);
            };

            socket.onclose = (event) => {
                console.log("WebSocket 연결 종료", event.code, event.reason);
                isSocketInitialized = false; // WebSocket이 닫히면 초기화 상태 해제
            };

            socket.onerror = (error) => {
                console.error("WebSocket 오류:", error);
            };
        }

        // DB에서 모든 Waypoint를 불러와 한 번에 전송하는 함수
        async function sendAllWaypoints(pathId, reverse = false) {
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                console.error("WebSocket 연결이 열려 있지 않습니다. 연결을 재설정합니다.");
                initializeWebSocket(); // WebSocket을 다시 초기화
                alert("WebSocket 연결이 닫혀 있습니다. 다시 시도해 주세요.");
                return;
            }

            try {
                // Supabase에서 Waypoint 데이터를 불러오기
                const { data: waypoints, error } = await supabase
                    .from('Waypoint')
                    .select('latitude, longitude, name, type, yaw')
                    .eq('pathId', pathId)
                    .order('id', { ascending: true }); // 항상 id 기준 정렬 유지

                if (error) {
                    console.error('Waypoint 데이터 조회 오류:', error);
                    return;
                }

                if (waypoints.length === 0) {
                    alert("선택된 Path에 Waypoint가 없습니다.");
                    return;
                }

                let waypointsToSend = waypoints;
                
                if (reverse) {
                    // Waypoints 순서를 역순으로 변경하고, yaw(heading)를 반전 (라디안 기준)
                    const pi = Math.PI;
                    waypointsToSend = waypoints.reverse().map(wp => ({
                        ...wp,
                        yaw: (wp.yaw + pi) % (2 * pi) // yaw 값을 라디안으로 반전
                    }));
                }

                // Waypoints 배열을 한 번에 WebSocket으로 전송
                const waypointData = {
                    command: "start_navigation",
                    waypoints: waypointsToSend.map(wp => ({
                        latitude: wp.latitude,
                        longitude: wp.longitude,
                        heading: wp.yaw,
                        name: wp.name,
                        type: wp.type,

                    }))
                };

                // 전송할 Waypoint 데이터 콘솔에 출력 (확인용)
                console.log("전송할 WebSocket 데이터:", JSON.stringify(waypointData, null, 2));

                socket.send(JSON.stringify(waypointData));

            } catch (error) {
                console.error("Unexpected error while loading waypoints from database:", error);
            }
        }

        // Waypoint 데이터를 저장할 변수
        let currentPathWaypoints = [];
        let currentWaypointIndex = 0; // 현재 Waypoint의 인덱스
        
        

        // Waypoint 데이터를 불러와 지도에 표시하는 함수
        async function loadWaypointsFromDatabase(pathId) {
            waypointLayer.clearLayers(); // 기존 Waypoint 마커 제거
            currentPathWaypoints = []; // 새로운 경로로 초기화

            try {
                const { data: waypoints, error } = await supabase
                    .from('Waypoint')
                    .select('id, latitude, longitude, name, type, yaw, color')
                    .eq('pathId', pathId)
                    .order('name', { ascending: true }); // Name 기준 오름차순으로 정렬

                if (error) {
                    console.error('Waypoint 데이터 조회 오류:', error);
                    return;
                }

                currentPathWaypoints = waypoints; // 현재 경로의 Waypoints를 저장

                waypoints.forEach((waypoint, index) => {
                    const { id, latitude, longitude, name, type, yaw, color } = waypoint;
                    const latlng = [latitude, longitude];
                    

                    const marker = L.marker(latlng, {
                        title: name,
                        icon: L.divIcon({
                            className: 'custom-div-icon',
                            html: `<img src="arrow.png" alt="Waypoint Icon" style="transform: rotate(${2*Math.PI-yaw}rad);"/>`,
                            iconSize: [15, 15],
                        }),
                        draggable: false,
                    }).addTo(waypointLayer);

                    // 마커 클릭 시 Waypoint 정보 표시
                    marker.on('click', () => showWaypointInfoPopup(id, latlng, name, latitude, longitude, yaw, type));

                    // Waypoints 간의 선 연결
                    if (index > 0) {
                        const previousLatLng = [waypoints[index - 1].latitude, waypoints[index - 1].longitude];
                        const polyline = L.polyline([previousLatLng, latlng], { color: color || '#3388ff' }).addTo(waypointLayer);
                    }
                });
            } catch (error) {
                console.error("Unexpected error while loading waypoints from database:", error);
            }
        }

        // Waypoint 정보 표시 팝업 생성 함수
        function showWaypointInfoPopup(id, latlng, name, latitude, longitude, yaw, type) {
            L.popup()
                .setLatLng(latlng)
                .setContent(`
                    <div style="font-size: 14px;">
                        <strong>Waypoint 정보</strong><br>
                        <strong>Name:</strong> ${name}<br>
                        <strong>Latitude:</strong> ${latitude}<br>
                        <strong>Longitude:</strong> ${longitude}<br>
                        <strong>Yaw:</strong> ${yaw}<br>
                        <strong>Type:</strong> ${type}<br>
                        <button onclick="enterEditMode(${id})">Edit</button>
                        <button onclick="deleteWaypoint(${id})" style="color: red;">Delete</button>
                    </div>
                `)
                .openOn(map); // 지도 위에 팝업 표시
        }

        // Waypoint 데이터를 저장할 변수
        const initialLatLngs = {};
        const initialYaws = {};

        // 첫 번째 편집 모드로 전환하는 함수
        function enterEditMode(id) {
            const waypoint = currentPathWaypoints.find(wp => wp.id === id);

            if (!waypoint) {
                console.error("Waypoint를 찾을 수 없습니다.");
                return;
            }

            const { latitude, longitude, name, yaw, type } = waypoint;

            initialLatLngs[name] = [latitude, longitude]; // 초기 위치 저장
            initialYaws[name] = yaw;                      // 초기 yaw 값 저장

            const popup = L.popup()
                .setLatLng([latitude, longitude])
                .setContent(`
                    <div style="font-size: 14px;">
                        <strong>Edit Waypoint 정보</strong><br>
                        <label>Name:</label> ${name} <button onclick="enterSecondEditMode('${id}', 'name')">Edit</button><br>
                        <label>Type:</label> ${type} <button onclick="enterSecondEditMode('${id}', 'type')">Edit</button><br>
                        <strong>Latitude/Longitude:</strong> ${latitude.toFixed(6)}, ${longitude.toFixed(6)} 
                        <button onclick="enterSecondEditMode('${id}', 'location')">Edit Location</button><br>
                        <strong>Yaw:</strong> ${yaw.toFixed(2)} <button onclick="enterSecondEditMode('${id}', 'direction')">Edit Direction</button><br>
                    </div>
                `)
                .openOn(map); // 지도 위에 편집 팝업 표시
            
            popup.on('remove', closePopupAndReset);
        }

        // 두 번째 편집 모드로 전환하는 함수
        function enterSecondEditMode(id, field) {
            const waypoint = currentPathWaypoints.find(wp => wp.id === Number(id));

            if (!waypoint) {
                console.error("Waypoint를 찾을 수 없습니다.");
                return;
            }

            const { latitude, longitude, name, yaw, type } = waypoint;

            let contentHtml = `<div style="font-size: 14px;"><strong>Edit ${field} 정보</strong><br>`;

            if (field === 'name') {
                contentHtml += `
                    <label>Name:</label> <input type="text" id="editName" value="${name}"><br>
                    <button onclick="saveEditedValue('${id}', 'name')">Save</button>
                `;
            } else if (field === 'type') {
                contentHtml += `
                    <label>Type:</label> <input type="text" id="editType" value="${type}"><br>
                    <button onclick="saveEditedValue('${id}', 'type')">Save</button>
                `;
            } else if (field === 'location') {
                contentHtml += `
                    <strong>Latitude:</strong> <span id="editLatitude">${latitude.toFixed(6)}</span><br>
                    <strong>Longitude:</strong> <span id="editLongitude">${longitude.toFixed(6)}</span><br>
                    <button onclick="saveEditedValue('${id}', 'location')">Save Location</button>
                    <button onclick="closePopupAndReset()">Close</button>
                    <p style="font-size:12px;color:gray;">지도에서 아이콘을 드래그하여 새 위치를 설정하세요.</p>
                `;

                const marker = waypointLayer.getLayers().find(layer => 
                    layer instanceof L.Marker && layer.options.title === waypoint.name
                );

                if (marker) {
                    marker.dragging.enable();

                    // 드래그 시작 시 팝업을 숨깁니다
                    marker.on('dragstart', () => {
                        map.closePopup();
                    });

                    // 드래그 종료 시 위치 업데이트 및 팝업을 다시 표시
                    marker.on('dragend', (e) => {
                        const updatedLatLng = e.target.getLatLng();

                        // 업데이트된 위도와 경도 값을 팝업에 반영하기 위해 직접 설정
                        // const latitudeElement = document.getElementById("editLatitude");
                        // const longitudeElement = document.getElementById("editLongitude");

                        // if (latitudeElement && longitudeElement) {
                        //     latitudeElement.innerText = updatedLatLng.lat.toFixed(6);
                        //     longitudeElement.innerText = updatedLatLng.lng.toFixed(6);
                        // }


                        // 드래그 종료 후 팝업을 다시 표시하는 함수
                        const updatedContentHtml = `
                            <div style="font-size: 14px;">
                                <strong>Edit Waypoint 정보</strong><br>
                                <label>Latitude:</label> <span id="editLatitude">${updatedLatLng.lat.toFixed(6)}<br>
                                <label>Longitude:</label> <span id="editLongitude">${updatedLatLng.lng.toFixed(6)}<br>
                                <button onclick="saveEditedValue('${id}', 'location')">Save Location</button>
                                <button onclick="closePopupAndReset()">Close</button>
                            </div>
                        `;

                        const popup = L.popup()
                            .setLatLng(updatedLatLng)
                            .setContent(updatedContentHtml)
                            .openOn(map);

                        popup.on('remove', closePopupAndReset); // X 버튼 또는 Close 버튼이 눌릴 때 초기화
                    });
                } else {
                    console.error("해당 ID의 마커를 찾을 수 없습니다.");
                }
            } else if (field === 'direction') {
                contentHtml += `
                    <strong>Yaw:</strong> <span id="editYaw">${yaw.toFixed(2)}</span><br>
                    <input type="range" id="yawSlider" min="0" max="${2 * Math.PI}" step="0.01" value="${yaw}">
                    <button onclick="saveEditedValue('${id}', 'direction')">Save Direction</button>
                    <button onclick="closePopupAndReset()">Close</button>
                    <p style="font-size:12px;color:gray;">슬라이더를 사용하여 방향을 조정하세요.</p>
                `;
            }

            contentHtml += `</div>`;

            // L.popup을 사용해 마커에 팝업 표시
            const popup = L.popup()
                .setLatLng([latitude, longitude])
                .setContent(contentHtml)
                .openOn(map);

            // 마커를 찾아 변수에 할당
            const marker = waypointLayer.getLayers().find(layer => 
                layer instanceof L.Marker && layer.options.title === waypoint.name
            );

            if (!marker) {
                console.error("해당 ID의 마커를 찾을 수 없습니다.");
                return;
            }

            // Popup이 열리고 난 후 슬라이더와 yaw 디스플레이 요소 가져오기
            setTimeout(() => {
                const yawDisplay = document.getElementById("editYaw");
                const yawSlider = document.getElementById("yawSlider");

                // 슬라이더 요소와 yaw 디스플레이 확인
                if (yawSlider && yawDisplay) {

                    // 슬라이더 조작 시 yaw 값 업데이트
                    yawSlider.addEventListener('input', (e) => {
                        const newYaw = parseFloat(e.target.value);
                        updateMarkerDirection(marker, newYaw); // 마커 회전 업데이트
                        yawDisplay.innerText = newYaw.toFixed(2); // yaw 값 업데이트

                    });
                } 
            }, 100); // Popup 렌더링 후 요소를 찾기 위해 약간의 지연을 추가
            popup.on('remove', closePopupAndReset);
        }

        

        // 편집 모드 취소 시 초기 값으로 되돌리는 함수
        function closePopupAndReset() {
            map.closePopup();

            waypointLayer.eachLayer(layer => {
                if (layer instanceof L.Marker && initialLatLngs[layer.options.title]) {
                    const waypointName = layer.options.title;
                    
                    // 초기 위치와 yaw 값이 존재하는 경우에만 복원
                    if (initialLatLngs[waypointName]) {
                        const [initialLat, initialLng] = initialLatLngs[waypointName];
                        layer.setLatLng([initialLat, initialLng]); // 초기 위치로 복원
                    }

                    if (initialYaws[waypointName] !== undefined) {
                        updateMarkerDirection(layer, initialYaws[waypointName]); // 초기 yaw 값으로 복원
                    }

                } 
            });
        }

        async function saveEditedValue(id, field) {
            let updateData = {};

            if (field === 'name') {
                updateData.name = document.getElementById("editName").value;
            } else if (field === 'type') {
                updateData.type = document.getElementById("editType").value;
            } else if (field === 'location') {
                const latitudeElement = document.getElementById("editLatitude");
                const longitudeElement = document.getElementById("editLongitude");

                if (!latitudeElement || !longitudeElement) {
                    console.error("Location elements not found.");
                    return;
                }

                updateData.latitude = parseFloat(latitudeElement.innerText);
                updateData.longitude = parseFloat(longitudeElement.innerText);
                
            } else if (field === 'direction') {
                updateData.yaw = parseFloat(document.getElementById("editYaw").innerText);
            }

            const { error } = await supabase.from('Waypoint').update(updateData).eq('id', id);

            if (error) {
                console.error('Waypoint 업데이트 오류:', error);
                alert('Waypoint 업데이트에 실패했습니다.');
            } else {
                alert('Waypoint 업데이트가 완료되었습니다.');
                map.closePopup();
                loadWaypointsFromDatabase(pathId);
            }
        }

        // yaw 계산 함수
        function calculateYaw(startLatLng, endLatLng) {
            const deltaX = endLatLng.lng - startLatLng.lng;
            const deltaY = endLatLng.lat - startLatLng.lat;
            return Math.atan2(deltaY, deltaX); // 라디안으로 반환
        }

        // 마커 회전 업데이트 함수
        function updateMarkerDirection(marker, yaw) {
            marker.setIcon(L.divIcon({
                className: 'custom-div-icon',
                html: `<img src="arrow.png" alt="Waypoint Icon" style="transform: rotate(${2*Math.PI-yaw}rad);"/>`,
                iconSize: [15, 15],
            }));
        }
        

        // 특정 Path ID로 Waypoints를 불러와 모두 전송
        function startNavigation(pathId) {
            if (!isSocketInitialized) {
                initializeWebSocket(); // WebSocket이 초기화되어 있지 않으면 초기화
            }
            sendAllWaypoints(pathId); // Waypoints를 한 번에 전송
        }

        // 기존의 startNavigation 함수와 유사하게 Waypoints를 역순으로 전송하는 함수 추가
        function startReverseNavigation(pathId) {
            if (!isSocketInitialized) {
                initializeWebSocket(); // WebSocket이 초기화되어 있지 않으면 초기화
            }
            sendAllWaypoints(pathId, true); // 역방향 Waypoints 전송을 위한 플래그 추가
        }

        // 특정 Path ID로 Waypoints를 불러와 지도에 표시
        function showWaypointsForPath(pathId) {
            loadWaypointsFromDatabase(pathId);
        }

        // WebSocket 초기화
        initializeWebSocket();

        // 웨이포인트 삭제 함수
        async function deleteWaypoint(id) {
            // 사용자 확인
            const confirmDelete = confirm("정말 이 웨이포인트를 삭제하시겠습니까?");
            if (!confirmDelete) return;

            // Supabase에서 해당 웨이포인트 삭제
            const { error } = await supabase.from('Waypoint').delete().eq('id', id);

            if (error) {
                console.error('웨이포인트 삭제 오류:', error);
                alert('웨이포인트 삭제에 실패했습니다.');
            } else {
                alert('웨이포인트가 성공적으로 삭제되었습니다.');
                map.closePopup(); // 팝업 닫기
                loadWaypointsFromDatabase(pathId); // 삭제 후 Waypoints 다시 불러오기
            }
        }

        
        // Add Waypoint 모드를 활성화하여 지도에 터치 이벤트를 추가
        function enableAddWaypointMode(pathId) {

            alert("지도를 터치하여 Waypoint의 위치를 설정하세요.");
            
            let startLatLng = null; // 초기 터치 위치 저장용
            let isDragging = false;
            let tempMarker = null;

            document.addEventListener('touchstart', _onTouchStart, { passive: false });
            document.addEventListener('touchmove', _onTouchMove, { passive: false });
            document.addEventListener('touchend', _onTouchEnd, { passive: false });

            // 이벤트 바인딩
            map.on('touchstart', _onTouchStart, { passive: false });
            map.on('touchmove', _onTouchMove, { passive: false });
            map.on('touchend', _onTouchEnd, { passive: false });

            // Waypoint 생성 1단계: Point 세팅 (터치 시작)
            function _onTouchStart(e) {
                console.log("Touching!");
                // 두 손가락 이상일 경우 포인트 생성 중지
                if (e.touches.length > 1) return;

                isDragging = true;

                // 터치 위치 가져오기
                const touch = e.touches[0];
                const containerPoint = map.mouseEventToContainerPoint(touch);
                startLatLng = map.containerPointToLatLng(containerPoint);

                e.preventDefault();
                e.stopPropagation();

                map.dragging.disable(); // 맵 드래그 비활성화

                // 임시 마커 생성
                tempMarker = L.marker(startLatLng, {
                    icon: L.divIcon({
                        className: 'custom-div-icon',
                        html: '<img src="arrow.png" alt="Waypoint Icon" style="transform: rotate(0rad);"/>',
                        iconSize: [15, 15],
                    }),
                    draggable: false,
                }).addTo(map);
            }

            // Waypoint 생성 2단계: Heading 세팅 (터치한 채로 드래그)
            function _onTouchMove(e) {
                console.log("Moving!");
                if (!isDragging) return;

                e.preventDefault();
                e.stopPropagation();

                const touch = e.touches[0];
                const containerPoint = map.mouseEventToContainerPoint(touch);
                const currentLatLng = map.containerPointToLatLng(containerPoint);
                const angle = calculateHeading(startLatLng, currentLatLng);

                // yaw에 따라 아이콘 회전
                tempMarker.setLatLng(startLatLng);
                const arrowElement = tempMarker.getElement().querySelector('img');
                arrowElement.style.transform = `rotate(${1.57 - angle}rad)`;
            }

            // Waypoint 생성 3단계: 최종 Waypoint 생성 (터치 해제)
            function _onTouchEnd(e) {
                console.log("End!");
                if (!isDragging) return;

                isDragging = false;
                e.preventDefault();
                e.stopPropagation();

                map.dragging.enable(); // 맵 드래그 재활성화

                const endLatLng = map.containerPointToLatLng(map.mouseEventToContainerPoint(e.changedTouches[0]));
                const heading = calculateHeading(startLatLng, endLatLng);

                // Waypoint 세부사항 입력 팝업 열기
                openWaypointDetailsPopup(startLatLng, heading, pathId);

                // 임시 마커 제거
                map.removeLayer(tempMarker);
                tempMarker = null;

                // 이벤트 해제
                map.off('touchstart', _onTouchStart);
                map.off('touchmove', _onTouchMove);
                map.off('touchend', _onTouchEnd);

                // `document` 이벤트 해제 (중복 방지)
                document.removeEventListener('touchstart', _onTouchStart);
                document.removeEventListener('touchmove', _onTouchMove);
                document.removeEventListener('touchend', _onTouchEnd);
            }
        }


        // Waypoint 상세 정보 입력 팝업
        function openWaypointDetailsPopup(latlng, yaw, pathId) {

            const waypointPopup = document.createElement('div');
            waypointPopup.id = 'newWaypointPopup';
            waypointPopup.style = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 90%;
                max-width: 300px;
                padding: 20px;
                background-color: #ffffff;
                border-radius: 8px;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
                font-size: 14px;
                z-index: 1000;
            `;

            waypointPopup.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3 style="margin: 0; font-size: 18px;">Add Waypoint</h3>
                    <button onclick="closeWaypointPopup()" style="background: none; border: none; font-size: 20px; font-weight: bold; cursor: pointer;">&times;</button>
                </div>
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    <label>Name (순서):</label>
                    <input type="number" id="newWaypointName" placeholder="Enter Order" style="padding: 8px; border: 1px solid #ddd; border-radius: 5px; font-size: 14px;" min="1" />
                    
                    <label>Description:</label>
                    <input type="text" id="newWaypointDescription" placeholder="Enter Description" style="padding: 8px; border: 1px solid #ddd; border-radius: 5px; font-size: 14px;"/>

                    <label>Type:</label>
                    <input type="text" id="newWaypointType" placeholder="Enter Type" style="padding: 8px; border: 1px solid #ddd; border-radius: 5px; font-size: 14px;"/>
                </div>
                <div style="display: flex; justify-content: space-between; margin-top: 15px;">
                    <button onclick="addNewWaypoint(${latlng.lat}, ${latlng.lng}, ${yaw}, ${pathId})" style="width: 48%; padding: 10px; font-size: 16px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">Save</button>
                    <button onclick="closeWaypointPopup()" style="width: 48%; padding: 10px; font-size: 16px; background-color: #f8f9fa; color: black; border: 1px solid #ddd; border-radius: 5px; cursor: pointer;">Cancel</button>
                </div>
            `;

            document.body.appendChild(waypointPopup);
        }

        // Waypoint 추가 함수
        async function addNewWaypoint(latitude, longitude, yaw, pathId) {
            const name = parseInt(document.getElementById("newWaypointName").value);
            const description = document.getElementById("newWaypointDescription").value;
            const type = document.getElementById("newWaypointType").value;
            const color = getRandomColor(); // 랜덤 색상 생성

            if (isNaN(name) || !description || !type) {
                alert("모든 필드를 정확히 입력하세요.");
                return;
            }

            // 이름을 기준으로 순서 정렬 (중간 삽입 가능)
            await adjustWaypointOrder(pathId, name);

            const { error } = await supabase.from('Waypoint').insert([{ pathId, latitude, longitude, yaw, color, name, description, type }]);

            if (error) {
                console.error("Waypoint 추가 오류:", error);
                alert("Waypoint 추가에 실패했습니다.");
            } else {
                alert("새로운 Waypoint가 추가되었습니다.");
                closeWaypointPopup();
                // 추가 후 Waypoints 목록을 다시 불러오거나 업데이트하는 함수를 호출해 갱신
            }
        }

        // 순서 정렬을 위한 Waypoint 이름 조정 함수
        async function adjustWaypointOrder(pathId, newOrder) {
            const { data: waypoints, error } = await supabase.from('Waypoint')
                .select('id, name')
                .eq('pathId', pathId)
                .order('name', { ascending: true });

            if (error) {
                console.error('Waypoint 순서 조정 오류:', error);
                return;
            }

            const updates = [];
            let currentOrder = newOrder;

            // 새 Waypoint가 중간에 삽입될 경우 이후 Waypoints의 name을 증가
            waypoints.forEach(waypoint => {
                if (waypoint.name >= newOrder) {
                    updates.push(supabase.from('Waypoint').update({ name: ++currentOrder }).eq('id', waypoint.id));
                }
            });

            await Promise.all(updates); // 모든 업데이트 작업 수행
        }

        // 팝업 닫기 함수
        function closeWaypointPopup() {
            const waypointPopup = document.querySelector('#newWaypointPopup');
            if (waypointPopup) {
                document.body.removeChild(waypointPopup);
            }
        }

        // 랜덤 색상 생성 함수
        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

    </script>
</body>
</html>
